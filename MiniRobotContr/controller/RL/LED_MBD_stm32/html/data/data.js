var dataJson = {"arch":{"ispc":true,"isunix":false,"ismac":false},"build":"LED_MBD","ref":false,"files":[{"name":"LED_MBD.c","type":"source","group":"model","path":"E:\\DR_Han\\小人形关节整合\\controller\\RL\\LED_MBD_stm32","tag":"","groupDisplay":"模型文件","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: LED_MBD.c\r\n *\r\n * Code generated for Simulink model :LED_MBD.\r\n *\r\n * Model version      : 1.14\r\n * Simulink Coder version    : 9.9 (R2023a) 19-Nov-2022\r\n * TLC version       : 9.9 (Nov  8 2023)\r\n * C/C++ source code generated on  : Sat Nov  9 16:29:02 2024\r\n *\r\n * Target selection: stm32.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n *\r\n *\r\n *\r\n * ******************************************************************************\r\n * * attention\r\n * *\r\n * * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS\r\n * * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE\r\n * * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY\r\n * * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING\r\n * * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE\r\n * * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.\r\n * *\r\n * ******************************************************************************\r\n */\r\n\r\n#include \"LED_MBD.h\"\r\n#include \"LED_MBD_private.h\"\r\n#include \"LED_MBD_dt.h\"\r\n\r\n/* Real-time model */\r\nstatic RT_MODEL_LED_MBD LED_MBD_M_;\r\nRT_MODEL_LED_MBD *const LED_MBD_M = &LED_MBD_M_;\r\n\r\n/* Model step function */\r\nvoid LED_MBD_step(void)\r\n{\r\n  {\r\n    if (LED_MBD_P.Constant5_Value != TIM3_Conf.CH3_duty) {\r\n      TIM3_Conf.CH3_duty = LED_MBD_P.Constant5_Value;\r\n      if (LED_MBD_P.Constant5_Value >= 0) {\r\n        /* Channel3 duty cycle is an input port. */\r\n        __HAL_TIM_SET_COMPARE(&htim3,TIM_CHANNEL_3,(uint32_t)\r\n                              (LED_MBD_P.Constant5_Value * (&htim3)->\r\n          Instance->ARR / 100));\r\n      }\r\n    }\r\n\r\n    if (LED_MBD_P.Constant6_Value != TIM3_Conf.CH4_duty) {\r\n      TIM3_Conf.CH4_duty = LED_MBD_P.Constant6_Value;\r\n      if (LED_MBD_P.Constant6_Value >= 0) {\r\n        /* Channe4 duty cycle is an input port. */\r\n        __HAL_TIM_SET_COMPARE(&htim3,TIM_CHANNEL_4,(uint32_t)\r\n                              (LED_MBD_P.Constant6_Value * (&htim3)->\r\n          Instance->ARR / 100));\r\n      }\r\n    }\r\n  }\r\n\r\n  /* External mode */\r\n  rtExtModeUploadCheckTrigger(1);\r\n\r\n  {                                    /* Sample time: [0.001s, 0.0s] */\r\n    rtExtModeUpload(0, (real_T)LED_MBD_M->Timing.taskTime0);\r\n  }\r\n\r\n  /* signal main to stop simulation */\r\n  {                                    /* Sample time: [0.001s, 0.0s] */\r\n    if ((rtmGetTFinal(LED_MBD_M)!=-1) &&\r\n        !((rtmGetTFinal(LED_MBD_M)-LED_MBD_M->Timing.taskTime0) >\r\n          LED_MBD_M->Timing.taskTime0 * (DBL_EPSILON))) {\r\n      rtmSetErrorStatus(LED_MBD_M, \"Simulation finished\");\r\n    }\r\n\r\n    if (rtmGetStopRequested(LED_MBD_M)) {\r\n      rtmSetErrorStatus(LED_MBD_M, \"Simulation finished\");\r\n    }\r\n  }\r\n\r\n  /* Update absolute time for base rate */\r\n  /* The \"clockTick0\" counts the number of times the code of this task has\r\n   * been executed. The absolute time is the multiplication of \"clockTick0\"\r\n   * and \"Timing.stepSize0\". Size of \"clockTick0\" ensures timer will not\r\n   * overflow during the application lifespan selected.\r\n   */\r\n  LED_MBD_M->Timing.taskTime0 =\r\n    ((time_T)(++LED_MBD_M->Timing.clockTick0)) * LED_MBD_M->Timing.stepSize0;\r\n}\r\n\r\n/* Model initialize function */\r\nvoid LED_MBD_initialize(void)\r\n{\r\n  /* Registration code */\r\n  rtmSetTFinal(LED_MBD_M, 10.0);\r\n  LED_MBD_M->Timing.stepSize0 = 0.001;\r\n\r\n  /* External mode info */\r\n  LED_MBD_M->Sizes.checksums[0] = (441520903U);\r\n  LED_MBD_M->Sizes.checksums[1] = (2103388976U);\r\n  LED_MBD_M->Sizes.checksums[2] = (2994867160U);\r\n  LED_MBD_M->Sizes.checksums[3] = (2549944052U);\r\n\r\n  {\r\n    static const sysRanDType rtAlwaysEnabled = SUBSYS_RAN_BC_ENABLE;\r\n    static RTWExtModeInfo rt_ExtModeInfo;\r\n    static const sysRanDType *systemRan[2];\r\n    LED_MBD_M->extModeInfo = (&rt_ExtModeInfo);\r\n    rteiSetSubSystemActiveVectorAddresses(&rt_ExtModeInfo, systemRan);\r\n    systemRan[0] = &rtAlwaysEnabled;\r\n    systemRan[1] = &rtAlwaysEnabled;\r\n    rteiSetModelMappingInfoPtr(LED_MBD_M->extModeInfo,\r\n      &LED_MBD_M->SpecialInfo.mappingInfo);\r\n    rteiSetChecksumsPtr(LED_MBD_M->extModeInfo, LED_MBD_M->Sizes.checksums);\r\n    rteiSetTPtr(LED_MBD_M->extModeInfo, rtmGetTPtr(LED_MBD_M));\r\n  }\r\n\r\n  /* data type transition information */\r\n  {\r\n    static DataTypeTransInfo dtInfo;\r\n    (void) memset((char_T *) &dtInfo, 0,\r\n                  sizeof(dtInfo));\r\n    LED_MBD_M->SpecialInfo.mappingInfo = (&dtInfo);\r\n    dtInfo.numDataTypes = 23;\r\n    dtInfo.dataTypeSizes = &rtDataTypeSizes[0];\r\n    dtInfo.dataTypeNames = &rtDataTypeNames[0];\r\n\r\n    /* Parameters transition table */\r\n    dtInfo.PTransTable = &rtPTransTable;\r\n  }\r\n\r\n  {\r\n    /* user code (Start function Header) */\r\n    {\r\n      /* TIM3 initialization. */\r\n      /* Store TIM3 informations and its handler. */\r\n      G_TIM_Conf[G_TIM_Count] = &TIM3_Conf;\r\n      G_TIM_Handler[G_TIM_Count] = &htim3;\r\n\r\n      /* Store TIM information. */\r\n      TIM3_Conf.TIM_Prescaler = 71;\r\n      TIM3_Conf.TIM_APBClock = 72000000;\r\n      TIM3_Conf.TIM_ARR = 1000 - 1;\r\n      TIM3_Conf.TIM_Clock = 1.0E+6;\r\n      TIM3_Conf.TIM_Freq = 1000.0;\r\n      TIM3_Conf.CH1_duty = 0.0;\r\n      TIM3_Conf.CH2_duty = 0.0;\r\n      TIM3_Conf.CH3_duty = 50.0;\r\n      TIM3_Conf.CH4_duty = 50.0;\r\n      TIM3_Conf.CH1_type = UNKNOWN;\r\n      TIM3_Conf.CH2_type = UNKNOWN;\r\n      TIM3_Conf.CH3_type = OUTPUT_PWM;\r\n      TIM3_Conf.CH4_type = OUTPUT_PWM;\r\n\r\n      /* Interrupt handler default initialization. */\r\n      TIM3_Conf.ItUpFcn = NULL;\r\n      TIM3_Conf.ItTrgFcn = NULL;\r\n      TIM3_Conf.ItComFcn = NULL;\r\n      TIM3_Conf.ItBrkFcn = NULL;\r\n      TIM3_Conf.ItCcFcn = NULL;\r\n\r\n      /* Auto-reload preload enable */\r\n      /*****Bugzilla 63376 *****/\r\n      /*SET_BIT((&htim3)->Instance->CR1,TIM_CR1_ARPE);*/\r\n\r\n      /* Update register value with blockset value. */\r\n      /* Prescaler. */\r\n      __HAL_TIM_SET_PRESCALER(&htim3,TIM3_Conf.TIM_Prescaler);\r\n\r\n      /* Autoreload: ARR. */\r\n      __HAL_TIM_SET_AUTORELOAD(&htim3,1000 - 1);\r\n\r\n      /* Set CH3 Pulse value. */\r\n      __HAL_TIM_SET_COMPARE(&htim3,TIM_CHANNEL_3,(uint32_t)(500));\r\n\r\n      /* Set CH4 Pulse value. */\r\n      __HAL_TIM_SET_COMPARE(&htim3,TIM_CHANNEL_4,(uint32_t)(500));\r\n\r\n      /* Update registers before start operation to come. */\r\n      HAL_TIM_GenerateEvent(&htim3,TIM_EVENTSOURCE_UPDATE);\r\n    }\r\n\r\n    /* user code (Start function Body) */\r\n    {\r\n      /* TIM3 Start. */\r\n\r\n      /* Wait for htim3 State READY. */\r\n      while ((&htim3)->State == HAL_TIM_STATE_BUSY) {\r\n      }\r\n\r\n      HAL_TIM_PWM_Start(&htim3,TIM_CHANNEL_3);\r\n\r\n      /* Wait for htim3 State READY. */\r\n      while ((&htim3)->State == HAL_TIM_STATE_BUSY) {\r\n      }\r\n\r\n      HAL_TIM_PWM_Start(&htim3,TIM_CHANNEL_4);\r\n    }\r\n  }\r\n}\r\n\r\n/* File trailer for Real-Time Workshop generated code.\r\n *\r\n * [EOF] LED_MBD.c\r\n */\r\n"},{"name":"LED_MBD.h","type":"header","group":"model","path":"E:\\DR_Han\\小人形关节整合\\controller\\RL\\LED_MBD_stm32","tag":"","groupDisplay":"模型文件","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: LED_MBD.h\r\n *\r\n * Code generated for Simulink model :LED_MBD.\r\n *\r\n * Model version      : 1.14\r\n * Simulink Coder version    : 9.9 (R2023a) 19-Nov-2022\r\n * TLC version       : 9.9 (Nov  8 2023)\r\n * C/C++ source code generated on  : Sat Nov  9 16:29:02 2024\r\n *\r\n * Target selection: stm32.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n *\r\n *\r\n *\r\n * ******************************************************************************\r\n * * attention\r\n * *\r\n * * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS\r\n * * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE\r\n * * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY\r\n * * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING\r\n * * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE\r\n * * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.\r\n * *\r\n * ******************************************************************************\r\n */\r\n\r\n#ifndef RTW_HEADER_LED_MBD_h_\r\n#define RTW_HEADER_LED_MBD_h_\r\n#ifndef LED_MBD_COMMON_INCLUDES_\r\n#define LED_MBD_COMMON_INCLUDES_\r\n#include \"rtwtypes.h\"\r\n#include \"rtw_extmode.h\"\r\n#include \"sysran_types.h\"\r\n#include \"dt_info.h\"\r\n#include \"ext_work.h\"\r\n#endif                                 /* LED_MBD_COMMON_INCLUDES_ */\r\n\r\n#include \"LED_MBD_TIM.h\"\r\n#include \"STM32_Config.h\"\r\n#include \"LED_MBD_External_Functions.h\"\r\n#include \"LED_MBD_types.h\"\r\n#include <float.h>\r\n#include <string.h>\r\n\r\n/* Macros for accessing real-time model data structure */\r\n#ifndef rtmGetFinalTime\r\n#define rtmGetFinalTime(rtm)           ((rtm)->Timing.tFinal)\r\n#endif\r\n\r\n#ifndef rtmGetRTWExtModeInfo\r\n#define rtmGetRTWExtModeInfo(rtm)      ((rtm)->extModeInfo)\r\n#endif\r\n\r\n#ifndef rtmGetErrorStatus\r\n#define rtmGetErrorStatus(rtm)         ((rtm)->errorStatus)\r\n#endif\r\n\r\n#ifndef rtmSetErrorStatus\r\n#define rtmSetErrorStatus(rtm, val)    ((rtm)->errorStatus = (val))\r\n#endif\r\n\r\n#ifndef rtmGetStopRequested\r\n#define rtmGetStopRequested(rtm)       ((rtm)->Timing.stopRequestedFlag)\r\n#endif\r\n\r\n#ifndef rtmSetStopRequested\r\n#define rtmSetStopRequested(rtm, val)  ((rtm)->Timing.stopRequestedFlag = (val))\r\n#endif\r\n\r\n#ifndef rtmGetStopRequestedPtr\r\n#define rtmGetStopRequestedPtr(rtm)    (&((rtm)->Timing.stopRequestedFlag))\r\n#endif\r\n\r\n#ifndef rtmGetT\r\n#define rtmGetT(rtm)                   ((rtm)->Timing.taskTime0)\r\n#endif\r\n\r\n#ifndef rtmGetTFinal\r\n#define rtmGetTFinal(rtm)              ((rtm)->Timing.tFinal)\r\n#endif\r\n\r\n#ifndef rtmGetTPtr\r\n#define rtmGetTPtr(rtm)                (&(rtm)->Timing.taskTime0)\r\n#endif\r\n\r\n/* Parameters (default storage) */\r\nstruct P_LED_MBD_ {\r\n  real_T Constant5_Value;              /* Expression: 50\r\n                                        * Referenced by: '<S1>/Constant5'\r\n                                        */\r\n  real_T Constant6_Value;              /* Expression: 20\r\n                                        * Referenced by: '<S1>/Constant6'\r\n                                        */\r\n};\r\n\r\n/* Real-time Model Data Structure */\r\nstruct tag_RTM_LED_MBD {\r\n  const char_T *errorStatus;\r\n  RTWExtModeInfo *extModeInfo;\r\n\r\n  /*\r\n   * Sizes:\r\n   * The following substructure contains sizes information\r\n   * for many of the model attributes such as inputs, outputs,\r\n   * dwork, sample times, etc.\r\n   */\r\n  struct {\r\n    uint32_T checksums[4];\r\n  } Sizes;\r\n\r\n  /*\r\n   * SpecialInfo:\r\n   * The following substructure contains special information\r\n   * related to other components that are dependent on RTW.\r\n   */\r\n  struct {\r\n    const void *mappingInfo;\r\n  } SpecialInfo;\r\n\r\n  /*\r\n   * Timing:\r\n   * The following substructure contains information regarding\r\n   * the timing information for the model.\r\n   */\r\n  struct {\r\n    time_T taskTime0;\r\n    uint32_T clockTick0;\r\n    time_T stepSize0;\r\n    time_T tFinal;\r\n    boolean_T stopRequestedFlag;\r\n  } Timing;\r\n};\r\n\r\n/* Block parameters (default storage) */\r\nextern P_LED_MBD LED_MBD_P;\r\n\r\n/* Model entry point functions */\r\nextern void LED_MBD_initialize(void);\r\nextern void LED_MBD_step(void);\r\n\r\n/* Real-time Model object */\r\nextern RT_MODEL_LED_MBD *const LED_MBD_M;\r\n\r\n/*-\r\n * The generated code includes comments that allow you to trace directly\r\n * back to the appropriate location in the model.  The basic format\r\n * is <system>/block_name, where system is the system number (uniquely\r\n * assigned by Simulink) and block_name is the name of the block.\r\n *\r\n * Use the MATLAB hilite_system command to trace the generated code back\r\n * to the model.  For example,\r\n *\r\n * hilite_system('<S3>')    - opens system 3\r\n * hilite_system('<S3>/Kp') - opens and selects block Kp which resides in S3\r\n *\r\n * Here is the system hierarchy for this model\r\n *\r\n * '<Root>' : 'LED_MBD'\r\n * '<S1>'   : 'LED_MBD/Function-Call Subsystem'\r\n */\r\n#endif                                 /* RTW_HEADER_LED_MBD_h_ */\r\n\r\n/* File trailer for Real-Time Workshop generated code.\r\n *\r\n * [EOF] LED_MBD.h\r\n */\r\n"},{"name":"LED_MBD_private.h","type":"header","group":"model","path":"E:\\DR_Han\\小人形关节整合\\controller\\RL\\LED_MBD_stm32","tag":"","groupDisplay":"模型文件","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: LED_MBD_private.h\r\n *\r\n * Code generated for Simulink model :LED_MBD.\r\n *\r\n * Model version      : 1.14\r\n * Simulink Coder version    : 9.9 (R2023a) 19-Nov-2022\r\n * TLC version       : 9.9 (Nov  8 2023)\r\n * C/C++ source code generated on  : Sat Nov  9 16:29:02 2024\r\n *\r\n * Target selection: stm32.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n *\r\n *\r\n *\r\n * ******************************************************************************\r\n * * attention\r\n * *\r\n * * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS\r\n * * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE\r\n * * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY\r\n * * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING\r\n * * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE\r\n * * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.\r\n * *\r\n * ******************************************************************************\r\n */\r\n\r\n#ifndef RTW_HEADER_LED_MBD_private_h_\r\n#define RTW_HEADER_LED_MBD_private_h_\r\n#include \"rtwtypes.h\"\r\n#include \"multiword_types.h\"\r\n#include \"LED_MBD_types.h\"\r\n\r\n/* Private macros used by the generated code to access rtModel */\r\n#ifndef rtmSetTFinal\r\n#define rtmSetTFinal(rtm, val)         ((rtm)->Timing.tFinal = (val))\r\n#endif\r\n#endif                                 /* RTW_HEADER_LED_MBD_private_h_ */\r\n\r\n/* File trailer for Real-Time Workshop generated code.\r\n *\r\n * [EOF] LED_MBD_private.h\r\n */\r\n"},{"name":"LED_MBD_types.h","type":"header","group":"model","path":"E:\\DR_Han\\小人形关节整合\\controller\\RL\\LED_MBD_stm32","tag":"","groupDisplay":"模型文件","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: LED_MBD_types.h\r\n *\r\n * Code generated for Simulink model :LED_MBD.\r\n *\r\n * Model version      : 1.14\r\n * Simulink Coder version    : 9.9 (R2023a) 19-Nov-2022\r\n * TLC version       : 9.9 (Nov  8 2023)\r\n * C/C++ source code generated on  : Sat Nov  9 16:29:02 2024\r\n *\r\n * Target selection: stm32.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n *\r\n *\r\n *\r\n * ******************************************************************************\r\n * * attention\r\n * *\r\n * * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS\r\n * * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE\r\n * * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY\r\n * * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING\r\n * * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE\r\n * * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.\r\n * *\r\n * ******************************************************************************\r\n */\r\n\r\n#ifndef RTW_HEADER_LED_MBD_types_h_\r\n#define RTW_HEADER_LED_MBD_types_h_\r\n\r\n/* Parameters (default storage) */\r\ntypedef struct P_LED_MBD_ P_LED_MBD;\r\n\r\n/* Forward declaration for rtModel */\r\ntypedef struct tag_RTM_LED_MBD RT_MODEL_LED_MBD;\r\n\r\n#endif                                 /* RTW_HEADER_LED_MBD_types_h_ */\r\n\r\n/* File trailer for Real-Time Workshop generated code.\r\n *\r\n * [EOF] LED_MBD_types.h\r\n */\r\n"},{"name":"LED_MBD_data.c","type":"source","group":"data","path":"E:\\DR_Han\\小人形关节整合\\controller\\RL\\LED_MBD_stm32","tag":"","groupDisplay":"数据文件","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: LED_MBD_data.c\r\n *\r\n * Code generated for Simulink model :LED_MBD.\r\n *\r\n * Model version      : 1.14\r\n * Simulink Coder version    : 9.9 (R2023a) 19-Nov-2022\r\n * TLC version       : 9.9 (Nov  8 2023)\r\n * C/C++ source code generated on  : Sat Nov  9 16:29:02 2024\r\n *\r\n * Target selection: stm32.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n *\r\n *\r\n *\r\n * ******************************************************************************\r\n * * attention\r\n * *\r\n * * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS\r\n * * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE\r\n * * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY\r\n * * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING\r\n * * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE\r\n * * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.\r\n * *\r\n * ******************************************************************************\r\n */\r\n\r\n#include \"LED_MBD.h\"\r\n\r\n/* Block parameters (default storage) */\r\nP_LED_MBD LED_MBD_P = {\r\n  /* Expression: 50\r\n   * Referenced by: '<S1>/Constant5'\r\n   */\r\n  50.0,\r\n\r\n  /* Expression: 20\r\n   * Referenced by: '<S1>/Constant6'\r\n   */\r\n  20.0\r\n};\r\n\r\n/* File trailer for Real-Time Workshop generated code.\r\n *\r\n * [EOF] LED_MBD_data.c\r\n */\r\n"},{"name":"multiword_types.h","type":"header","group":"utility","path":"E:\\DR_Han\\小人形关节整合\\controller\\RL\\LED_MBD_stm32","tag":"","groupDisplay":"实用工具文件","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: multiword_types.h\r\n *\r\n * Code generated for Simulink model :LED_MBD.\r\n *\r\n * Model version      : 1.14\r\n * Simulink Coder version    : 9.9 (R2023a) 19-Nov-2022\r\n * TLC version       : 9.9 (Nov  8 2023)\r\n * C/C++ source code generated on  : Sat Nov  9 16:29:02 2024\r\n *\r\n * Target selection: stm32.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n *\r\n *\r\n *\r\n * ******************************************************************************\r\n * * attention\r\n * *\r\n * * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS\r\n * * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE\r\n * * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY\r\n * * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING\r\n * * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE\r\n * * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.\r\n * *\r\n * ******************************************************************************\r\n */\r\n\r\n#ifndef MULTIWORD_TYPES_H\r\n#define MULTIWORD_TYPES_H\r\n#include \"rtwtypes.h\"\r\n\r\n/*\r\n * Definitions supporting external data access\r\n */\r\ntypedef int64_T chunk_T;\r\ntypedef uint64_T uchunk_T;\r\n\r\n#endif                                 /* MULTIWORD_TYPES_H */\r\n\r\n/* File trailer for Real-Time Workshop generated code.\r\n *\r\n * [EOF] multiword_types.h\r\n */\r\n"},{"name":"rtwtypes.h","type":"header","group":"utility","path":"E:\\DR_Han\\小人形关节整合\\controller\\RL\\LED_MBD_stm32","tag":"","groupDisplay":"实用工具文件","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: rtwtypes.h\r\n *\r\n * Code generated for Simulink model :LED_MBD.\r\n *\r\n * Model version      : 1.14\r\n * Simulink Coder version    : 9.9 (R2023a) 19-Nov-2022\r\n * TLC version       : 9.9 (Nov  8 2023)\r\n * C/C++ source code generated on  : Sat Nov  9 16:29:02 2024\r\n *\r\n * Target selection: stm32.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n *\r\n *\r\n *\r\n * ******************************************************************************\r\n * * attention\r\n * *\r\n * * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS\r\n * * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE\r\n * * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY\r\n * * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING\r\n * * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE\r\n * * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.\r\n * *\r\n * ******************************************************************************\r\n */\r\n\r\n#ifndef RTWTYPES_H\r\n#define RTWTYPES_H\r\n\r\n/* Logical type definitions */\r\n#if (!defined(__cplusplus))\r\n#ifndef false\r\n#define false                          (0U)\r\n#endif\r\n\r\n#ifndef true\r\n#define true                           (1U)\r\n#endif\r\n#endif\r\n\r\n/*=======================================================================*\r\n * Target hardware information\r\n *   Device type: ARM Compatible->ARM Cortex\r\n *   Number of bits:     char:   8    short:   16    int:  32\r\n *                       long:  32    long long:  64\r\n *                       native word size:  32\r\n *   Byte ordering: LittleEndian\r\n *   Signed integer division rounds to: Zero\r\n *   Shift right on a signed integer as arithmetic shift: on\r\n *=======================================================================*/\r\n\r\n/*=======================================================================*\r\n * Fixed width word size data types:                                     *\r\n *   int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *\r\n *   uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *\r\n *   real32_T, real64_T           - 32 and 64 bit floating point numbers *\r\n *=======================================================================*/\r\ntypedef signed char int8_T;\r\ntypedef unsigned char uint8_T;\r\ntypedef short int16_T;\r\ntypedef unsigned short uint16_T;\r\ntypedef int int32_T;\r\ntypedef unsigned int uint32_T;\r\ntypedef long long int64_T;\r\ntypedef unsigned long long uint64_T;\r\ntypedef float real32_T;\r\ntypedef double real64_T;\r\n\r\n/*===========================================================================*\r\n * Generic type definitions: boolean_T, char_T, byte_T, int_T, uint_T,       *\r\n *                           real_T, time_T, ulong_T, ulonglong_T.           *\r\n *===========================================================================*/\r\ntypedef double real_T;\r\ntypedef double time_T;\r\ntypedef unsigned char boolean_T;\r\ntypedef int int_T;\r\ntypedef unsigned int uint_T;\r\ntypedef unsigned long ulong_T;\r\ntypedef unsigned long long ulonglong_T;\r\ntypedef char char_T;\r\ntypedef unsigned char uchar_T;\r\ntypedef char_T byte_T;\r\n\r\n/*===========================================================================*\r\n * Complex number type definitions                                           *\r\n *===========================================================================*/\r\n#define CREAL_T\r\n\r\ntypedef struct {\r\n  real32_T re;\r\n  real32_T im;\r\n} creal32_T;\r\n\r\ntypedef struct {\r\n  real64_T re;\r\n  real64_T im;\r\n} creal64_T;\r\n\r\ntypedef struct {\r\n  real_T re;\r\n  real_T im;\r\n} creal_T;\r\n\r\n#define CINT8_T\r\n\r\ntypedef struct {\r\n  int8_T re;\r\n  int8_T im;\r\n} cint8_T;\r\n\r\n#define CUINT8_T\r\n\r\ntypedef struct {\r\n  uint8_T re;\r\n  uint8_T im;\r\n} cuint8_T;\r\n\r\n#define CINT16_T\r\n\r\ntypedef struct {\r\n  int16_T re;\r\n  int16_T im;\r\n} cint16_T;\r\n\r\n#define CUINT16_T\r\n\r\ntypedef struct {\r\n  uint16_T re;\r\n  uint16_T im;\r\n} cuint16_T;\r\n\r\n#define CINT32_T\r\n\r\ntypedef struct {\r\n  int32_T re;\r\n  int32_T im;\r\n} cint32_T;\r\n\r\n#define CUINT32_T\r\n\r\ntypedef struct {\r\n  uint32_T re;\r\n  uint32_T im;\r\n} cuint32_T;\r\n\r\n#define CINT64_T\r\n\r\ntypedef struct {\r\n  int64_T re;\r\n  int64_T im;\r\n} cint64_T;\r\n\r\n#define CUINT64_T\r\n\r\ntypedef struct {\r\n  uint64_T re;\r\n  uint64_T im;\r\n} cuint64_T;\r\n\r\n/*=======================================================================*\r\n * Min and Max:                                                          *\r\n *   int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *\r\n *   uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *\r\n *=======================================================================*/\r\n#define MAX_int8_T                     ((int8_T)(127))\r\n#define MIN_int8_T                     ((int8_T)(-128))\r\n#define MAX_uint8_T                    ((uint8_T)(255U))\r\n#define MAX_int16_T                    ((int16_T)(32767))\r\n#define MIN_int16_T                    ((int16_T)(-32768))\r\n#define MAX_uint16_T                   ((uint16_T)(65535U))\r\n#define MAX_int32_T                    ((int32_T)(2147483647))\r\n#define MIN_int32_T                    ((int32_T)(-2147483647-1))\r\n#define MAX_uint32_T                   ((uint32_T)(0xFFFFFFFFU))\r\n#define MAX_int64_T                    ((int64_T)(9223372036854775807LL))\r\n#define MIN_int64_T                    ((int64_T)(-9223372036854775807LL-1LL))\r\n#define MAX_uint64_T                   ((uint64_T)(0xFFFFFFFFFFFFFFFFULL))\r\n\r\n/* Block D-Work pointer type */\r\ntypedef void * pointer_T;\r\n\r\n#endif                                 /* RTWTYPES_H */\r\n\r\n/* File trailer for Real-Time Workshop generated code.\r\n *\r\n * [EOF] rtwtypes.h\r\n */\r\n"},{"name":"LED_MBD_dt.h","type":"header","group":"interface","path":"E:\\DR_Han\\小人形关节整合\\controller\\RL\\LED_MBD_stm32","tag":"","groupDisplay":"接口文件","code":"/*\r\n * LED_MBD_dt.h\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"LED_MBD\".\r\n *\r\n * Model version              : 1.14\r\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\r\n * C source code generated on : Sat Nov  9 16:29:02 2024\r\n *\r\n * Target selection: stm32.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"ext_types.h\"\r\n\r\n/* data type size table */\r\nstatic uint_T rtDataTypeSizes[] = {\r\n  sizeof(real_T),\r\n  sizeof(real32_T),\r\n  sizeof(int8_T),\r\n  sizeof(uint8_T),\r\n  sizeof(int16_T),\r\n  sizeof(uint16_T),\r\n  sizeof(int32_T),\r\n  sizeof(uint32_T),\r\n  sizeof(boolean_T),\r\n  sizeof(fcn_call_T),\r\n  sizeof(int_T),\r\n  sizeof(pointer_T),\r\n  sizeof(action_T),\r\n  2*sizeof(uint32_T),\r\n  sizeof(int32_T),\r\n  sizeof(int64_T),\r\n  sizeof(uint64_T),\r\n  sizeof(uint64_T),\r\n  sizeof(int64_T),\r\n  sizeof(uint_T),\r\n  sizeof(char_T),\r\n  sizeof(uchar_T),\r\n  sizeof(time_T)\r\n};\r\n\r\n/* data type name table */\r\nstatic const char_T * rtDataTypeNames[] = {\r\n  \"real_T\",\r\n  \"real32_T\",\r\n  \"int8_T\",\r\n  \"uint8_T\",\r\n  \"int16_T\",\r\n  \"uint16_T\",\r\n  \"int32_T\",\r\n  \"uint32_T\",\r\n  \"boolean_T\",\r\n  \"fcn_call_T\",\r\n  \"int_T\",\r\n  \"pointer_T\",\r\n  \"action_T\",\r\n  \"timer_uint32_pair_T\",\r\n  \"physical_connection\",\r\n  \"int64_T\",\r\n  \"uint64_T\",\r\n  \"uint64_T\",\r\n  \"int64_T\",\r\n  \"uint_T\",\r\n  \"char_T\",\r\n  \"uchar_T\",\r\n  \"time_T\"\r\n};\r\n\r\n/* data type transitions for Parameters structure */\r\nstatic DataTypeTransition rtPTransitions[] = {\r\n  { (char_T *)(&LED_MBD_P.Constant5_Value), 0, 0, 2 }\r\n};\r\n\r\n/* data type transition table for Parameters structure */\r\nstatic DataTypeTransitionTable rtPTransTable = {\r\n  1U,\r\n  rtPTransitions\r\n};\r\n\r\n/* [EOF] LED_MBD_dt.h */\r\n"},{"name":"rtiostream_utils.c","type":"source","group":"interface","path":"D:\\Program Files\\MATLAB\\R2023a\\toolbox\\coder\\rtiostream\\src\\utils","tag":"","groupDisplay":"接口文件","code":"/* Copyright 2012-2013 The MathWorks, Inc. */\n\n#include \"rtiostream_utils.h\"\n\n/* include rtIOStream interface to use */\n#include \"rtiostream.h\" \n\n/* TARGET_CONNECTIVITY_TESTING might be defined by some MathWorks tests for\n * testing purposes only. In this case, we force SIZE_MAX to be 4 so we \n * could test the pointer arithmetic in rtIOStreamBlockingSend and\n * rtIOStreamBlockingRecv.\n */ \n#ifdef TARGET_CONNECTIVITY_TESTING\n    #define SIZE_MAX 4\n#else\n    /* define SIZE_MAX if not already defined (e.g. by a C99 compiler) */\n    #ifndef SIZE_MAX\n        #define SIZE_MAX ((size_t)-1)\n    #endif\n#endif\n\n#ifndef MemUnit_T\n   /* External Mode */\n   typedef unsigned char IOUnit_T; \n#else\n   /* SIL/PIL */\n   #ifdef HOST_WORD_ADDRESSABLE_TESTING\n      /* rtIOStream will handle data in single byte chunks \n       *\n       * uint8_T can be > 8-bits for certain portable word sizes \n       * cases (e.g. C2000) so use native type instead */\n      typedef unsigned char IOUnit_T;\n   #else\n      /* rtIOStream will handle data in MemUnit_T size chunks */\n      typedef MemUnit_T IOUnit_T;\n   #endif\n#endif\n\n/* Blocks until all requested outgoing data is sent */\nint rtIOStreamBlockingSend(const int streamID, \n                           const void * const src, \n                           uint32_T size) {\n\n    size_t transferAmount;\n    size_t sizeSent;\n    int errorCode      = RTIOSTREAM_NO_ERROR;   \n    const IOUnit_T * srcPtr = (const IOUnit_T *) src;\n    \n    /* use a variable to avoid SIZE_MAX being treated as a constant\n     * which leads to compiler warnings for \"MIN\" on platforms where\n     * SIZE_MAX > UINT32_MAX */\n    size_t sizeMax = SIZE_MAX;\n    while (size > 0) {\n        /* support full uint32 size */\n        transferAmount = (size_t) MIN(sizeMax, size);        \n        errorCode = rtIOStreamSend(streamID,\n                                   (const void *) srcPtr,\n                                   transferAmount,\n                                   &sizeSent);\n        if (errorCode == RTIOSTREAM_ERROR) {\n            return errorCode;\n        }\n        else {            \n            size -= (uint32_T) sizeSent;\n            srcPtr += sizeSent;\n        }\n    }\n    return errorCode;\n}\n\n/* Blocks until all requested incoming data is received */\nint rtIOStreamBlockingRecv(const int streamID,\n                           void * const dst,\n                           uint32_T size) {\n\n   size_t transferAmount;\n   size_t sizeRecvd;\n   int errorCode      = RTIOSTREAM_NO_ERROR;\n   IOUnit_T * dstPtr = (IOUnit_T *) dst;\n   \n   /* use a variable to avoid SIZE_MAX being treated as a constant\n    * which leads to compiler warnings for \"MIN\" on platforms where \n    * SIZE_MAX > UINT32_MAX */\n   size_t sizeMax = SIZE_MAX;\n   while (size > 0) {\n      /* support full uint32 size */\n      transferAmount = (size_t) MIN(sizeMax, size);      \n      errorCode = rtIOStreamRecv(streamID, \n                                 (void *) dstPtr, \n                                 transferAmount, \n                                 &sizeRecvd);\n      if (errorCode == RTIOSTREAM_ERROR) {\n            return errorCode;\n      }\n      else {          \n         size -= (uint32_T) sizeRecvd;\n         dstPtr += sizeRecvd;\n      }\n   }\n   return errorCode;\n}\n\n\n"},{"name":"LED_MBD_External_Functions.h","type":"header","group":"","path":"E:\\DR_Han\\小人形关节整合\\controller\\RL\\LED_MBD_stm32","tag":"","groupDisplay":"其他文件","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: LED_MBD_External_Functions.h\r\n *\r\n * Code generated for Simulink model :LED_MBD.\r\n *\r\n * Model version      : 1.14\r\n * Simulink Coder version    : 9.9 (R2023a) 19-Nov-2022\r\n * TLC version       : 9.9 (Nov  8 2023)\r\n * C/C++ source code generated on  : Sat Nov  9 16:29:02 2024\r\n *\r\n * Target selection: stm32.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n *\r\n *\r\n *\r\n * ******************************************************************************\r\n * * attention\r\n * *\r\n * * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS\r\n * * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE\r\n * * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY\r\n * * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING\r\n * * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE\r\n * * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.\r\n * *\r\n * ******************************************************************************\r\n */\r\n\r\n#ifndef RTW_HEADER_LED_MBD_External_Functions_h_\r\n#define RTW_HEADER_LED_MBD_External_Functions_h_\r\n\r\n/* Generated by STM32_Config.*/\r\n/***** External Imported Functions *****/\r\n#endif                            /* RTW_HEADER_LED_MBD_External_Functions_h_ */\r\n\r\n/* File trailer for Real-Time Workshop generated code.\r\n *\r\n * [EOF] LED_MBD_External_Functions.h\r\n */\r\n"},{"name":"LED_MBD_TIM.c","type":"source","group":"","path":"E:\\DR_Han\\小人形关节整合\\controller\\RL\\LED_MBD_stm32","tag":"","groupDisplay":"其他文件","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: LED_MBD_TIM.c\r\n *\r\n * Code generated for Simulink model :LED_MBD.\r\n *\r\n * Model version      : 1.14\r\n * Simulink Coder version    : 9.9 (R2023a) 19-Nov-2022\r\n * TLC version       : 9.9 (Nov  8 2023)\r\n * C/C++ source code generated on  : Sat Nov  9 16:29:02 2024\r\n *\r\n * Target selection: stm32.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n *\r\n *\r\n *\r\n * ******************************************************************************\r\n * * attention\r\n * *\r\n * * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS\r\n * * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE\r\n * * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY\r\n * * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING\r\n * * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE\r\n * * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.\r\n * *\r\n * ******************************************************************************\r\n */\r\n\r\n#include \"LED_MBD.h\"\r\n#include \"LED_MBD_TIM.h\"\r\n\r\n/* Number of configured TIMER. */\r\nuint16_t G_TIM_Count = 0;\r\n\r\n/* Array of TIMER information. */\r\nTIM_ConfTypeDef* G_TIM_Conf[1];\r\nTIM_HandleTypeDef* G_TIM_Handler[1];\r\n\r\n/* TIM3 informations. */\r\nTIM_ConfTypeDef TIM3_Conf;\r\n\r\n/* TIM3 polling timeout value. Number of Solver loop. (can be changed). */\r\nuint32_t G_TIM3_PollTimeOut = 10;\r\n\r\n/* File trailer for Real-Time Workshop generated code.\r\n *\r\n * [EOF] LED_MBD_TIM.c\r\n */\r\n"},{"name":"LED_MBD_TIM.h","type":"header","group":"","path":"E:\\DR_Han\\小人形关节整合\\controller\\RL\\LED_MBD_stm32","tag":"","groupDisplay":"其他文件","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: LED_MBD_TIM.h\r\n *\r\n * Code generated for Simulink model :LED_MBD.\r\n *\r\n * Model version      : 1.14\r\n * Simulink Coder version    : 9.9 (R2023a) 19-Nov-2022\r\n * TLC version       : 9.9 (Nov  8 2023)\r\n * C/C++ source code generated on  : Sat Nov  9 16:29:02 2024\r\n *\r\n * Target selection: stm32.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n *\r\n *\r\n *\r\n * ******************************************************************************\r\n * * attention\r\n * *\r\n * * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS\r\n * * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE\r\n * * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY\r\n * * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING\r\n * * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE\r\n * * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.\r\n * *\r\n * ******************************************************************************\r\n */\r\n\r\n#ifndef RTW_HEADER_LED_MBD_TIM_h_\r\n#define RTW_HEADER_LED_MBD_TIM_h_\r\n#include \"STM32_Config.h\"\r\n\r\n/**\r\n * @brief TIM informations\r\n */\r\ntypedef struct {\r\n  uint32_t TIM_Prescaler;\r\n  uint32_t TIM_APBClock;\r\n  uint32_t TIM_ARR;\r\n  uint32_t TIM_Clock;\r\n  uint32_t TIM_Freq;\r\n  uint8_t CH1_type;\r\n  uint8_t CH2_type;\r\n  uint8_t CH3_type;\r\n  uint8_t CH4_type;\r\n  int32_t CH1_duty;\r\n  int32_t CH2_duty;\r\n  int32_t CH3_duty;\r\n  int32_t CH4_duty;\r\n\r\n  /* Input Capture data. */\r\n  uint32_t* ICCData;\r\n  uint32_t ICC1Capture;\r\n  uint32_t ICC1Freq;\r\n  uint32_t ICC1Duty;\r\n  uint32_t ICC2Capture;\r\n  uint32_t ICC2Freq;\r\n  uint32_t ICC2Duty;\r\n  uint32_t ICC3Capture;\r\n  uint32_t ICC3Freq;\r\n  uint32_t ICC3Duty;\r\n  uint32_t ICC4Capture;\r\n  uint32_t ICC4Freq;\r\n  uint32_t ICC4Duty;\r\n  uint16_t ICC1ReadValue1;\r\n  uint16_t ICC1ReadValue2;\r\n  uint16_t ICC1ReadValue3;\r\n  uint16_t ICC1ReadValue4;\r\n  uint16_t ICC2ReadValue1;\r\n  uint16_t ICC2ReadValue2;\r\n  uint16_t ICC2ReadValue3;\r\n  uint16_t ICC2ReadValue4;\r\n  uint16_t ICC3ReadValue1;\r\n  uint16_t ICC3ReadValue2;\r\n  uint16_t ICC3ReadValue3;\r\n  uint16_t ICC3ReadValue4;\r\n  uint16_t ICC4ReadValue1;\r\n  uint16_t ICC4ReadValue2;\r\n  uint16_t ICC4ReadValue3;\r\n  uint16_t ICC4ReadValue4;\r\n  uint8_t ICC1CaptureNumber;\r\n  uint8_t ICC2CaptureNumber;\r\n  uint8_t ICC3CaptureNumber;\r\n  uint8_t ICC4CaptureNumber;\r\n  void (* ItUpFcn)(void);\r\n  void (* ItTrgFcn)(void);\r\n  void (* ItComFcn)(void);\r\n  void (* ItBrkFcn)(void);\r\n  void (* ItCcFcn)(TIM_HandleTypeDef *htim);\r\n} TIM_ConfTypeDef;\r\n\r\ntypedef enum {\r\n  OUTPUT_COMP = 0,\r\n  OUTPUT_PWM,\r\n  OUTPUT_TRGO,\r\n  OUTPUT_FORCED,\r\n  INPUT_PWM,\r\n  INPUT_CAPTURE,\r\n  INPUT_ETR,\r\n  INPUT_ENCODER,\r\n  INPUT_HALL_SENSOR,\r\n  UNKNOWN\r\n} TIM_ChTypeDef;\r\n\r\n/* Number of configured TIMER. */\r\nextern uint16_t G_TIM_Count;\r\n\r\n/* Array of TIMER information. */\r\nextern TIM_ConfTypeDef* G_TIM_Conf[1];\r\nextern TIM_HandleTypeDef* G_TIM_Handler[1];\r\n\r\n/* TIM3 handler. */\r\nextern TIM_HandleTypeDef htim3;\r\n\r\n/* TIM3 informations. */\r\nextern TIM_ConfTypeDef TIM3_Conf;\r\n\r\n/* TIM3 polling timeout value. Number of Solver loop. (can be changed). */\r\nextern uint32_t G_TIM3_PollTimeOut;\r\n\r\n#endif                                 /* RTW_HEADER_LED_MBD_TIM_h_ */\r\n\r\n/* File trailer for Real-Time Workshop generated code.\r\n *\r\n * [EOF] LED_MBD_TIM.h\r\n */\r\n"},{"name":"STM32_Config.h","type":"header","group":"","path":"E:\\DR_Han\\小人形关节整合\\controller\\RL\\LED_MBD_stm32","tag":"","groupDisplay":"其他文件","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: STM32_Config.h\r\n *\r\n * Code generated for Simulink model :LED_MBD.\r\n *\r\n * Model version      : 1.14\r\n * Simulink Coder version    : 9.9 (R2023a) 19-Nov-2022\r\n * TLC version       : 9.9 (Nov  8 2023)\r\n * C/C++ source code generated on  : Sat Nov  9 16:29:02 2024\r\n *\r\n * Target selection: stm32.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n *\r\n *\r\n *\r\n * ******************************************************************************\r\n * * attention\r\n * *\r\n * * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS\r\n * * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE\r\n * * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY\r\n * * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING\r\n * * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE\r\n * * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.\r\n * *\r\n * ******************************************************************************\r\n */\r\n\r\n#ifndef RTW_HEADER_STM32_Config_h_\r\n#define RTW_HEADER_STM32_Config_h_\r\n#include \"stm32f1xx.h\"\r\n#include \"stm32f1xx_hal.h\"\r\n\r\n/* For Error_Handler() declaration. */\r\n#include \"main.h\"\r\n#include \"rtwtypes.h\"\r\n#endif                                 /* RTW_HEADER_STM32_Config_h_ */\r\n\r\n/* File trailer for Real-Time Workshop generated code.\r\n *\r\n * [EOF] STM32_Config.h\r\n */\r\n"},{"name":"ext_svr.c","type":"source","group":"legacy","path":"D:\\Program Files\\MATLAB\\R2023a\\rtw\\c\\src\\ext_mode\\common","tag":"","groupDisplay":"其他文件","code":"/*\n * Copyright 1994-2021 The MathWorks, Inc.\n *\n * File: ext_svr.c     \n *\n * Abstract:\n *  External mode server interface (TCPIP example).  Provides functions\n *  that get called by main routine (model-name.c):\n *    o ExtParseArgsAndInitUD:  parse args and create UserData\n *    o ExtWaitForStartPkt:     return true if waiting for host to start\n *    o rt_ExtModeInit:         external mode initialization\n *    o rt_ExtModeSleep:        pause the process\n *    o rt_PktServerWork:       server for setting/getting packets from host\n *    o rt_PktServer:           server dispatcher - for multi-tasking targets\n *    o rt_UploadServerWork:    server for setting data upload packets on host\n *    o rt_UploadServer:        server dispatcher - for multi-tasking targets\n *    o rt_ExtModeShutdown:     external mode termination\n *\n *  Parameter downloading and data uploading supported for single and\n *  multi-tasking targets.\n */\n\n/*****************\n * Include files *\n *****************/\n\n/*ANSI C headers*/\n#ifndef EXTMODE_DISABLEPRINTF  \n#include <stdio.h>\n#endif\n\n#include <stdlib.h>\n#include <string.h>\n\n#if defined(VXWORKS)\n /*VxWorks headers*/\n# include <selectLib.h>\n# include <sockLib.h>\n# include <inetLib.h>\n# include <ioLib.h>\n# include <taskLib.h>\n#endif\n\n/*Real Time Workshop headers*/\n#include \"rtwtypes.h\"\n#include \"multiword_types.h\"\n#include \"rtw_extmode.h\"\n\n#include \"ext_types.h\"\n#include \"ext_share.h\"\n#include \"ext_test.h\"\n#include \"ext_svr_transport.h\"\n#include \"updown.h\"\n#include \"updown_util.h\"\n#include \"dt_info.h\"\n\n\n/*Uncomment to test 4 byte reals*/\n/*#define real_T float*/\n\n/***********************\n * Logical definitions *\n ***********************/\n#if (!defined(__cplusplus))\n#  ifndef false\n#   define false                       (0U)\n#  endif\n#  ifndef true\n#   define true                        (1U)\n#  endif\n#endif\n\n/**********************\n * External Variables *\n **********************/\nextern int_T           volatile startModel;\nextern TargetSimStatus volatile modelStatus;\n#ifdef VXWORKS\nextern SEM_ID uploadSem;\nextern SEM_ID pktSem;\n#endif\nextern boolean_T host_upstatus_is_uploading;\n\n/********************\n * Global Variables *\n ********************/\n\n/*\n * Flags.\n */\nPRIVATE boolean_T   connected       = false;\nPRIVATE boolean_T   commInitialized = false;\nboolean_T gblSetParamPktReceived = false;\n\n/*\n * Pointer to opaque user data (defined by ext_svr_transport.c).\n */\nPRIVATE ExtUserData *extUD          = NULL;\n\n/*\n * Buffer used to receive packets.\n */\nPRIVATE int_T pktBufSize = 0;\nPRIVATE char  *pktBuf    = NULL;\n\n\n#ifndef EXTMODE_DISABLESIGNALMONITORING\n#ifndef EXTMODE_DISABLEPRINTF \nPRIVATE char ERRMSG_PROCESSSELECTSIGNAL[] = \n            \"\\nError in UploadLogInfoInit(). Most likely a memory\\n\"\n            \"allocation error or an attempt to re-initialize the\\n\"\n            \"signal selection during the data logging process\\n\"\n            \"(i.e., multiple EXT_SELECT_SIGNAL packets were received\\n\"\n            \"before the logging session terminated or an\\n\"\n            \"EXT_CANCEL_LOGGING packet was received)\\n\";\n\nPRIVATE char ERRMSG_PROCESSSELECTTRIGGER[] = \n            \"\\nError in UploadInitTrigger(). Most likely a memory\\n\"\n            \"allocation error or an attempt to re-initialize the\\n\"\n            \"trigger selection during the data logging process\\n\"\n            \"(i.e., multiple EXT_SELECT_TRIGGER packets were received\\n\"\n            \"before the logging session terminated or an\\n\"\n            \"EXT_CANCEL_LOGGING packet was received)\\n\";\n#else\nPRIVATE char ERRMSG_PROCESSSELECTSIGNAL[] = \"\";\nPRIVATE char ERRMSG_PROCESSSELECTTRIGGER[] = \"\";\n#endif\n#endif\n\n/********************\n *  If DAEMON_MODE  *\n ********************/\n#ifdef DAEMON_MODE\n/*\n * This defines the size of each data chunk (in bytes) that the\n * daemon acknowledgment scheme uses for large data\n */\nconst int_T daemonChunkSize = 32;\n#endif\n\nPRIVATE boolean_T SendPktHdrToHost(const ExtModeAction action,\n                                         const int size);\n\n/*******************\n * Local Functions *\n *******************/\n\n/* Function: GrowRecvBufIfNeeded ===============================================\n * Abstract:\n *  Allocate or increase the size of buffer for receiving packets from target.\n */\nPRIVATE boolean_T GrowRecvBufIfNeeded(const int pktSize)\n{\n    if (pktSize > pktBufSize) {\n        if (pktBuf != NULL) {\n            free(pktBuf);\n            pktBufSize = 0;\n        }\n\n        pktBuf = (char *)malloc(pktSize);\n        if (pktBuf == NULL) return(EXT_ERROR);\n\n        pktBufSize = pktSize;\n    }\n    return(EXT_NO_ERROR);\n} /* end GrowRecvBufIfNeeded */\n\n\n/* Function: GetPktHdr =========================================================\n * Abstract:\n *  Attempts to retrieve a packet header from the host.  If a header is in \n *  fact retrieved, the reference arg, 'hdrAvail' will be returned as true.\n *\n *  EXT_NO_ERROR is returned on success, EXT_ERROR is returned on failure.\n *\n * NOTES:\n *  o It is not necessarily an error for 'hdrAvail' to be returned as false.\n *    It typically means that we were polling for packets and none were\n *    available.\n */\nPRIVATE boolean_T GetPktHdr(PktHeader *pktHdr, boolean_T *hdrAvail)\n{\n    int_T     nGot      = 0; /* assume */\n    int_T     nGotTotal = 0;\n    int_T     pktSize   = sizeof(PktHeader);\n    boolean_T error     = EXT_NO_ERROR;\n    \n    /* Get the header. */\n    while(nGotTotal < pktSize) {\n        error = ExtGetHostPkt(extUD,\n            pktSize - nGotTotal, &nGot, (char_T *)((char_T *)pktHdr + nGotTotal));\n        if (error) goto EXIT_POINT;\n\n        nGotTotal += nGot;\n\n        if (nGotTotal == 0) break;\n    }\n    assert((nGot == 0) || (nGotTotal == pktSize));\n\nEXIT_POINT:\n    *hdrAvail = (boolean_T)(nGot > 0);\n    return(error);\n} /* end GetPktHdr */\n\n\n/* Function: ClearPkt ==========================================================\n * Abstract:\n *  Remove the data from the communication line one byte at a time.  This\n *  function is called when there was not enough memory to receive an entire\n *  packet.  Since the data was never received, it must be discarded so that\n *  other packets can be sent.\n */\nPRIVATE void ClearPkt(const int pktSize)\n{\n    int_T     nGot;\n    boolean_T error     = EXT_NO_ERROR;\n    int_T     nGotTotal = 0;\n    char      buffer;\n\n    /* Get and discard the data one char at a time. */\n    while(nGotTotal < pktSize) {\n        error = ExtGetHostPkt(extUD, 1, &nGot, (char_T *)&buffer);\n        if (error) {\n#ifndef EXTMODE_DISABLEPRINTF            \n            fprintf(stderr,\"ExtGetHostPkt() failed.\\n\");\n#endif\n            goto EXIT_POINT;\n        }\n        nGotTotal += nGot;\n    }\n\nEXIT_POINT:\n    return;\n\n} /* end ClearPkt */\n\n#ifdef DAEMON_MODE\n/* Function: ClearPktUsingAck ==================================================\n * Abstract:\n *  Derived from ClearPkt(). For the general behaviour see ClearPkt() above.\n *  This variant is used by DAEMON_MODE to clear data in small chunks.\n *  After receiving each chunk reply with a EXT_DAEMON_ACK.\n */\nPRIVATE void ClearPktUsingAck(const int pktSize)\n{\n    int_T     nGot;\n    boolean_T error     = EXT_NO_ERROR;\n    int_T     nGotTotal = 0;\n    char      buffer;\n    \n    int_T     i;\n    int_T     nChunks   = pktSize/daemonChunkSize;\n    int_T     bytesLeft = pktSize%daemonChunkSize;\n\n    /* Get and discard the data one char at a time.\n\t * Receive chunks here, and reply with ack after receiving each chunk\n\t */\n    for(i=0; i<nChunks; i++){\n        nGotTotal = 0;\n        while(nGotTotal < daemonChunkSize){\n            error = ExtGetHostPkt(extUD,\n                        1,\n                        &nGot,\n                        (char_T *)&buffer);\n            if (error) {\n#ifndef EXTMODE_DISABLEPRINTF                \n                fprintf(stderr,\"ExtGetHostPkt() failed.\\n\");\n#endif\n                goto EXIT_POINT;\n            }\n            nGotTotal += nGot;\n        }\n        SendPktHdrToHost(EXT_DAEMON_ACK, 0);\n    }\n    \n    /*\n\t * Receive the bytes left over and reply with an ack after you receive all\n\t */\n    nGotTotal=0;\n    if(bytesLeft != 0){\n        while(nGotTotal<bytesLeft){\n            error = ExtGetHostPkt(extUD,\n                        1,\n                        &nGot,\n                        (char_T *)&buffer);\n            if (error) {\n#ifndef EXTMODE_DISABLEPRINTF                \n                fprintf(stderr,\"ExtGetHostPkt() failed.\\n\");\n#endif\n                goto EXIT_POINT;\n            }\n        nGotTotal += nGot;\n        }\n        SendPktHdrToHost(EXT_DAEMON_ACK, 0);\n    }\n\nEXIT_POINT:\n    return;\n\n} /* end ClearPktUsingAck */\n#endif\n\n\n/* Function: GetPkt ============================================================\n * Abstract:\n *  Receive nBytes from the host.  Return a buffer containing the bytes or\n *  NULL if an error occurs.  Note that the pointer returned is that of the\n *  global pktBuf.  If the buf needs to be grown to accommodate the package,\n *  it is realloc'd.  This function will try to get the requested number\n *  of bytes indefinitely - it is assumed that the data is either already there,\n *  or will show up in a \"reasonable\" amount of time.\n */\nPRIVATE const char *GetPkt(const int pktSize)\n{\n    int_T     nGot;\n    boolean_T error     = EXT_NO_ERROR;\n    int_T     nGotTotal = 0;\n\n    error = GrowRecvBufIfNeeded(pktSize);\n    if (error != EXT_NO_ERROR) {\n#ifndef EXTMODE_DISABLEPRINTF            \n        fprintf(stderr,\"Previous pkt from host thrown away due to lack of memory.\\n\");\n#endif\n        ClearPkt(pktSize);\n        goto EXIT_POINT;\n    }\n    \n    /* Get the data. */\n    while(nGotTotal < pktSize) {\n        error = ExtGetHostPkt(extUD,\n            pktSize - nGotTotal, &nGot, (char_T *)(pktBuf + nGotTotal));\n        if (error) {\n#ifndef EXTMODE_DISABLEPRINTF                \n            fprintf(stderr,\"ExtGetHostPkt() failed.\\n\");\n#endif\n            goto EXIT_POINT;\n        }\n\n    nGotTotal += nGot;\n    }\n\nEXIT_POINT:\n    return((error == EXT_NO_ERROR) ? pktBuf : NULL);\n} /* end GetPkt */\n\n#ifdef DAEMON_MODE\n/* Function: GetPktUsingAck ============================================================\n * Abstract:\n *  Derived from GetPkt(). For the general behaviour see GetPkt() above.\n *  This variant is used by DAEMON_MODE to fetch data in small chunks.\n *  After receiving each chunk reply with a EXT_DAEMON_ACK.\n */\nPRIVATE const char *GetPktUsingAck(const int pktSize)\n{\n    int_T     nGot;\n    boolean_T error     = EXT_NO_ERROR;\n    int_T     nGotTotal = 0;\n    \n    int_T     i;\n    int_T     nChunks   = pktSize/daemonChunkSize;\n    int_T     bytesLeft = pktSize%daemonChunkSize;\n\n    error = GrowRecvBufIfNeeded(pktSize);\n    if (error != EXT_NO_ERROR) {\n#ifndef EXTMODE_DISABLEPRINTF            \n        fprintf(stderr,\"Previous pkt from host thrown away due to lack of memory.\\n\");\n#endif\n        ClearPktUsingAck(pktSize);\n        goto EXIT_POINT;\n    }\n    \n    /*\n\t * Receive chunks here, and reply with ack after receiving each chunk\n\t */\n    for(i=0; i<nChunks; i++){\n        nGotTotal = 0;\n        while(nGotTotal < daemonChunkSize){\n            error = ExtGetHostPkt(extUD,\n                        daemonChunkSize - nGotTotal,\n                        &nGot,\n                        (char_T *)(pktBuf + i*daemonChunkSize + nGotTotal));\n            if (error) {\n#ifndef EXTMODE_DISABLEPRINTF                \n                fprintf(stderr,\"ExtGetHostPkt() failed.\\n\");\n#endif\n            goto EXIT_POINT;\n            }\n            nGotTotal += nGot;\n        }\n        SendPktHdrToHost(EXT_DAEMON_ACK, 0);\n    }\n    \n    /*\n\t * Receive the bytes left over and reply with an ack after you receive all\n\t */\n    nGotTotal=0;\n    if(bytesLeft != 0){\n        while(nGotTotal<bytesLeft){\n            error = ExtGetHostPkt(extUD,\n                        bytesLeft - nGotTotal,\n                        &nGot,\n                        (char_T *)(pktBuf + i*daemonChunkSize + nGotTotal));\n            if (error) {\n#ifndef EXTMODE_DISABLEPRINTF                \n                fprintf(stderr,\"ExtGetHostPkt() failed.\\n\");\n#endif\n                goto EXIT_POINT;\n            }\n        nGotTotal += nGot;\n        }\n        SendPktHdrToHost(EXT_DAEMON_ACK, 0);\n    }\n\nEXIT_POINT:\n    return((error == EXT_NO_ERROR) ? pktBuf : NULL);\n} /* end GetPktUsingAck */\n#endif\n\n\n#ifndef EXTMODE_DISABLESIGNALMONITORING\n/* Forward declaration */\nvoid UploadServerWork(int32_T, int_T numSampTimes);\n#endif\n\n/* Function: DisconnectFromHost ================================================\n * Abstract:\n *  Disconnect from the host.\n */\nPRIVATE void DisconnectFromHost(int_T numSampTimes)\n{\n    int i;\n    boolean_T upload_signals = host_upstatus_is_uploading;\n\n    for (i=0; i<NUM_UPINFOS; i++) {\n        UploadPrepareForFinalFlush(i);\n\n#if defined(VXWORKS)\n        /*\n         * UploadPrepareForFinalFlush() has already called semGive(uploadSem)\n         * two times.  Now the server thread will wait until the upload thread\n         * has processed all of the data in the buffers for the final upload\n         * and exhausted the uploadSem semaphores.  If the server thread\n         * attempts to call UploadServerWork() while the upload thread is in\n         * the middle of processing the buffers, the target code may crash\n         * with a NULL pointer exception (the buffers are destroyed after\n         * calling UploadLogInfoTerm).\n         */\n        while(semTake(uploadSem, NO_WAIT) != ERROR) {\n            semGive(uploadSem);\n            taskDelay(1000);\n        }\n#else\n#ifndef EXTMODE_DISABLESIGNALMONITORING\n        if (upload_signals) {\n            UploadServerWork(i, numSampTimes);\n        }\n#endif\n#endif\n\n        UploadLogInfoTerm(i, numSampTimes);\n    }\n    \n    connected       = false;\n    commInitialized = false;\n    \n    ExtCloseConnection(extUD);\n} /* end DisconnectFromHost */\n\n\n/* Function: ForceDisconnectFromHost ===========================================\n * Abstract:\n *  Force a disconnect from the host.  This is not a graceful shutdown and\n *  should only be used when the integrity of the external mode connection\n *  is in question.  To shutdown the connection gracefully, use\n *  DisconnectFromHost().\n */\nPRIVATE void ForceDisconnectFromHost(int_T numSampTimes)\n{\n    int i;\n    connected       = false;\n    commInitialized = false;\n\n    for (i=0; i<NUM_UPINFOS; i++) {\n        UploadEndLoggingSession(i, numSampTimes);\n    }\n\n    ExtForceDisconnect(extUD);\n} /* end ForceDisconnectFromHost */\n\n\n/* Function: ProcessConnectPkt =================================================\n * Abstract:\n *  Process the EXT_CONNECT packet and send response to host.\n */\nPRIVATE boolean_T ProcessConnectPkt(RTWExtModeInfo *ei)\n{\n    int_T                   nSet;\n    PktHeader               pktHdr;\n    int_T                   tmpBufSize;\n    uint32_T                *tmpBuf = NULL;\n    boolean_T               error   = EXT_NO_ERROR;\n    \n    const DataTypeTransInfo *dtInfo    = (const DataTypeTransInfo *) rteiGetModelMappingInfo(ei);\n    uint_T                  *dtSizes   = dtGetDataTypeSizes(dtInfo);\n    int_T                   nDataTypes = dtGetNumDataTypes(dtInfo);\n\n    assert(connected);\n    assert(!commInitialized);\n\n    /*\n     * Send the 1st of two EXT_CONNECT_RESPONSE packets to the host. \n     * The packet consists purely of the pktHeader.  In this special\n     * case the pktSize actually contains the number of bits per byte\n     * (not always 8 - see TI compiler for C30 and C40).\n     */\n    pktHdr.type = (uint32_T)EXT_CONNECT_RESPONSE;\n    pktHdr.size = (uint32_T)8; /* 8 bits per byte */\n\n    error = ExtSetHostPkt(extUD,sizeof(pktHdr),(char_T *)&pktHdr,&nSet);\n    if (error || (nSet != sizeof(pktHdr))) {\n#ifndef EXTMODE_DISABLEPRINTF            \n        fprintf(stderr,\n            \"ExtSetHostPkt() failed for 1st EXT_CONNECT_RESPONSE.\\n\");\n#endif\n        goto EXIT_POINT;\n    }\n\n    /* Send 2nd EXT_CONNECT_RESPONSE packet containing the following \n     * fields:\n     *\n     * CS1 - checksum 1 (uint32_T)\n     * CS2 - checksum 2 (uint32_T)\n     * CS3 - checksum 3 (uint32_T)\n     * CS4 - checksum 4 (uint32_T)\n     *\n     * intCodeOnly   - flag indicating if target is integer only (uint32_T)\n     * \n     * MWChunkSize   - multiword data type chunk size on target (uint32_T)\n     * \n     * targetStatus  - the status of the target (uint32_T)\n     *\n     * nDataTypes    - # of data types        (uint32_T)\n     * dataTypeSizes - 1 per nDataTypes       (uint32_T[])\n     */\n\n    {\n        int nPktEls    = 4 +                        /* checkSums       */\n                         1 +                        /* intCodeOnly     */\n                         1 +                        /* MW chunk size   */\n                         1 +                        /* targetStatus    */\n                         1 +                        /* nDataTypes      */\n                         dtGetNumDataTypes(dtInfo); /* data type sizes */\n\n        tmpBufSize = nPktEls * sizeof(uint32_T);\n        tmpBuf     = (uint32_T *)malloc(tmpBufSize);\n        if (tmpBuf == NULL) {\n            error = EXT_ERROR; goto EXIT_POINT;\n        }\n    }\n    \n    /* Send packet header. */\n    pktHdr.type = EXT_CONNECT_RESPONSE;\n    pktHdr.size = tmpBufSize;\n\n    error = ExtSetHostPkt(extUD,sizeof(pktHdr),(char_T *)&pktHdr,&nSet);\n    if (error || (nSet != sizeof(pktHdr))) {\n#ifndef EXTMODE_DISABLEPRINTF            \n        fprintf(stderr,\n            \"ExtSetHostPkt() failed for 2nd EXT_CONNECT_RESPONSE.\\n\");\n#endif\n        goto EXIT_POINT;\n    }\n   \n    /* Checksums, target status & SL_DOUBLESize. */\n    tmpBuf[0] = rteiGetChecksum0(ei);\n    tmpBuf[1] = rteiGetChecksum1(ei);\n    tmpBuf[2] = rteiGetChecksum2(ei);\n    tmpBuf[3] = rteiGetChecksum3(ei);\n\n#if INTEGER_CODE == 0\n    tmpBuf[4] = (uint32_T)0;\n#else\n    tmpBuf[4] = (uint32_T)1;\n#endif\n\n    tmpBuf[5] = (uint32_T)sizeof(uchunk_T);\n    \n    tmpBuf[6] = (uint32_T)modelStatus;\n\n    /* nDataTypes and dataTypeSizes */\n    {        \n        int i;\n        tmpBuf[7] = (uint32_T)nDataTypes;\n        for (i=0; i<nDataTypes; i++) {\n            tmpBuf[8+i] = (uint32_T)dtSizes[i];\n        }\n    }\n    \n    /* Send the packet. */\n    error = ExtSetHostPkt(extUD,tmpBufSize,(char_T *)tmpBuf,&nSet);\n    if (error || (nSet != tmpBufSize)) {\n#ifndef EXTMODE_DISABLEPRINTF            \n        fprintf(stderr,\n            \"ExtSetHostPkt() failed.\\n\");\n#endif\n        goto EXIT_POINT;\n    }\n\n    commInitialized = true;\n\nEXIT_POINT:\n    free(tmpBuf);\n    return(error);\n} /* end ProcessConnectPkt */\n\n\n/* Function: SendPktHdrToHost ==================================================\n * Abstract:\n *  Send a packet header to the host.\n */\nPRIVATE boolean_T SendPktHdrToHost(\n    const ExtModeAction action,\n    const int           size)  /* # of bytes to follow pkt header */\n{\n    int_T     nSet;\n    PktHeader pktHdr;\n    boolean_T error = EXT_NO_ERROR;\n\n    pktHdr.type = (uint32_T)action;\n    pktHdr.size = size;\n\n    error = ExtSetHostPkt(extUD,sizeof(pktHdr),(char_T *)&pktHdr,&nSet);\n    if (error || (nSet != sizeof(pktHdr))) {\n        error = EXT_ERROR;\n#ifndef EXTMODE_DISABLEPRINTF            \n        fprintf(stderr,\"ExtSetHostPkt() failed.\\n\");\n#endif\n        goto EXIT_POINT;\n    }\n\nEXIT_POINT:\n    return(error);\n} /* end SendPktHdrToHost */\n\n\n/* Function: SendPktDataToHost =================================================\n * Abstract:\n *  Send packet data to host. You are responsible for sending a header\n *  prior to sending the header.\n */\nPRIVATE boolean_T SendPktDataToHost(const char *data, const int size)\n{\n    int_T     nSet;\n    boolean_T error = EXT_NO_ERROR;\n\n    error = ExtSetHostPkt(extUD,size,data,&nSet);\n    if (error || (nSet != size)) {\n        error = EXT_ERROR;\n#ifndef EXTMODE_DISABLEPRINTF            \n        fprintf(stderr,\"ExtSetHostPkt() failed.\\n\");\n#endif\n        goto EXIT_POINT;\n    }\n\nEXIT_POINT:\n    return(error);\n} /* end SendPktDataToHost */\n\n\n/* Function: SendPktToHost =====================================================\n * Abstract:\n *  Send a packet to the host.  Packets can be of two forms:\n *      o packet header only\n *          the type is used as a flag to notify Simulink of an event\n *          that has taken place on the target (event == action == type)\n *      o pkt header, followed by data\n */\nPUBLIC boolean_T SendPktToHost(\n    const ExtModeAction action,\n    const int           size,  /* # of bytes to follow pkt header */\n    const char          *data)\n{\n    boolean_T error = EXT_NO_ERROR;\n    \n#ifdef VXWORKS\n    semTake(pktSem, WAIT_FOREVER);\n#endif\n\n    error = SendPktHdrToHost(action,size);\n    if (error != EXT_NO_ERROR) goto EXIT_POINT;\n\n    if (data != NULL) {\n        error = SendPktDataToHost(data, size);\n        if (error != EXT_NO_ERROR) goto EXIT_POINT;\n    } else {\n        assert(size == 0);\n    }\n\nEXIT_POINT:\n#ifdef VXWORKS\n    semGive(pktSem);\n#endif\n    return(error);\n} /* end SendPktToHost */\n\n\n/* Function:  SendResponseStatus ===============================================\n *  \n */\nPRIVATE boolean_T SendResponseStatus(const ExtModeAction  response,\n                                     const ResponseStatus status,\n                                     int32_T upInfoIdx)\n{\n    int32_T   msg[2];\n    boolean_T error = EXT_NO_ERROR;\n\n    msg[0] = (int32_T)status;\n    msg[1] = upInfoIdx;\n\n    error = SendPktToHost(response,2*sizeof(int32_T),(char_T *)&msg);\n    return(error);\n\n} /* end SendResponseStatus */\n\n\n#ifndef EXTMODE_DISABLEPARAMETERTUNING\n/* Function: ProcessSetParamPkt ================================================\n * Receive and process the EXT_SETPARAM packet.\n */\nPRIVATE boolean_T ProcessSetParamPkt(RTWExtModeInfo *ei,\n                                     const int pktSize)\n{\n    int32_T    msg;\n    const char *pkt;\n    boolean_T  error = EXT_NO_ERROR;\n\n    /*\n     * Receive packet and set parameters.\n     */\n    \n#ifdef DAEMON_MODE\n    pkt = GetPktUsingAck(pktSize);\n#else\n    pkt = GetPkt(pktSize);\n#endif\n\n    if (pkt == NULL) {\n        msg = (int32_T)NOT_ENOUGH_MEMORY;\n        SendPktToHost(EXT_SETPARAM_RESPONSE,sizeof(int32_T),(char_T *)&msg);\n        error = EXT_ERROR; \n        goto EXIT_POINT;\n    }\n    SetParam(ei, pkt);\n\n    msg = (int32_T)STATUS_OK;\n    error = SendPktToHost(EXT_SETPARAM_RESPONSE,sizeof(int32_T),(char_T *)&msg);\n    if (error != EXT_NO_ERROR) goto EXIT_POINT;\n\nEXIT_POINT:\n    return(error);\n} /* end ProcessSetParamPkt */\n#endif /* ifndef EXTMODE_DISABLEPARAMETERTUNING */\n\n#ifndef EXTMODE_DISABLEPARAMETERTUNING \n/* Function: ProcessGetParamsPkt ===============================================\n *  Respond to the hosts request for the parameters by gathering up all the\n *  params and sending them to the host.\n */\nPRIVATE boolean_T ProcessGetParamsPkt(RTWExtModeInfo *ei)\n{\n    int_T                         i;\n    int_T                         nBytesTotal;\n    boolean_T                     error    = EXT_NO_ERROR;\n    const DataTypeTransInfo       *dtInfo  = (const DataTypeTransInfo *) rteiGetModelMappingInfo(ei);\n    const DataTypeTransitionTable *dtTable = dtGetParamDataTypeTrans(dtInfo);\n\n    if (dtTable != NULL) {\n        /*\n         * We've got some params in the model.  Send their values to the\n         * host.\n         */\n        int_T        nTrans   = dtGetNumTransitions(dtTable);\n        const uint_T *dtSizes = dtGetDataTypeSizes(dtInfo);\n\n #ifdef VERBOSE\n    #ifndef EXTMODE_DISABLEPRINTF             \n        printf(\"\\nUploading initial parameters....\\n\");\n #endif\n#endif \n\n        /*\n         * Take pass 1 through the transitions to figure out how many\n         * bytes we're going to send.\n         */\n        nBytesTotal = 0;\n        for (i=0; i<nTrans; i++) {\n            int_T dt     = dtTransGetDataType(dtTable, i);\n            int_T dtSize = dtSizes[dt];\n            int_T nEls   = dtTransNEls(dtTable, i); /* complexity accounted for in trans tbl num of els */\n            int_T nBytes = dtSize * nEls;\n\n            nBytesTotal += nBytes;\n        }\n\n        /*\n         * Send the packet header.\n         */\n        error = SendPktHdrToHost(EXT_GETPARAMS_RESPONSE,nBytesTotal);\n        if (error != EXT_NO_ERROR) goto EXIT_POINT;\n\n        /*\n         * Take pass 2 through the transitions and send the parameters.\n         */\n        for (i=0; i<nTrans; i++) {\n            char_T *tranAddress  = dtTransGetAddress(dtTable, i);\n            int_T  dt            = dtTransGetDataType(dtTable, i);\n            int_T  dtSize        = dtSizes[dt];\n            int_T  nEls          = dtTransNEls(dtTable, i); /* complexity accounted for in trans tbl num of els */\n            int_T  nBytes        = dtSize * nEls;\n\n            error = SendPktDataToHost(tranAddress, nBytes);\n            if (error != EXT_NO_ERROR) goto EXIT_POINT;\n        }\n    } else {\n        /*\n         * We've got no params in the model.\n         */\n        error = SendPktHdrToHost(EXT_GETPARAMS_RESPONSE,0);\n        if (error != EXT_NO_ERROR) goto EXIT_POINT;\n    }\n\nEXIT_POINT:\n    return(error);\n} /* end ProcessGetParamsPkt */\n#endif /* ifndef EXTMODE_DISABLEPARAMETERTUNING */\n\n\n#ifndef EXTMODE_DISABLESIGNALMONITORING\n/* Function: ProcessSelectTriggerSignalPkt ===========================================\n * Receive and process the EXT_SELECT_TRIGGER or EXT_SELECT_SIGNALS packet.\n */\nPRIVATE boolean_T ProcessSelectTriggerSignalPkt(const ExtModeAction ACTION_ID, \n                                                RTWExtModeInfo *ei,\n                                                const int pktSize,\n                                                int_T numSampTimes,\n                                                char* errMsg)\n{\n    const char *pkt;\n    int32_T    upInfoIdx;\n    boolean_T  error = EXT_NO_ERROR;\n\n#ifdef DAEMON_MODE\n    pkt = GetPktUsingAck(pktSize);\n#else\n    pkt = GetPkt(pktSize);\n#endif\n\n    if (pkt == NULL) {\n        SendResponseStatus(ACTION_ID, NOT_ENOUGH_MEMORY, -1);\n        return(EXT_ERROR);\n    }\n\n    (void)memcpy(&upInfoIdx, pkt, sizeof(int32_T)); /* Extract upInfoIdx */\n    switch(ACTION_ID) {\n    case EXT_SELECT_TRIGGER_RESPONSE:\n#ifndef EXTMODE_DISABLEPRINTF  \n        PRINT_VERBOSE(\n                    (\"got EXT_SELECT_TRIGGER packet for upInfoIdx : %d\\n\", upInfoIdx));\n#endif\n        error = UploadInitTrigger(ei, pkt+sizeof(int32_T), upInfoIdx);\n        break;\n    case EXT_SELECT_SIGNALS_RESPONSE:\n#ifndef EXTMODE_DISABLEPRINTF  \n        PRINT_VERBOSE(\n                    (\"got EXT_SELECT_SIGNALS packet for upInfoIdx : %d\\n\", upInfoIdx));\n#endif\n        error = UploadLogInfoInit(ei, numSampTimes, pkt+sizeof(int32_T), upInfoIdx);\n        break;\n    default:\n        break;\n    }\n\n    if (error != EXT_NO_ERROR) {\n        SendResponseStatus(ACTION_ID, NOT_ENOUGH_MEMORY, upInfoIdx);\n#ifndef EXTMODE_DISABLEPRINTF            \n        printf(\"%s\\n\", errMsg);\n#endif\n        return(error);\n    }\n\n    error = SendResponseStatus(ACTION_ID, STATUS_OK, upInfoIdx);\n    return(error); /* Can be EXT_NO_ERROR */\n} /* end ProcessSelectTriggerSignalPkt */\n#endif /* ifndef EXTMODE_DISABLESIGNALMONITORING */\n\n\n#ifndef EXTMODE_DISABLESIGNALMONITORING\n/* Function: ProcessCancelLoggingArmTriggerPkt ===========================================\n * Receive and process the EXT_CANCEL_LOGGING or EXT_ARM_TRIGGER packet.\n */\nPRIVATE boolean_T ProcessCancelLoggingArmTriggerPkt(const ExtModeAction ACTION_ID, \n                        const int pktSize, \n                        int_T numSampTimes)\n{\n    const char *pkt;\n    int32_T    upInfoIdx;\n    boolean_T  error = EXT_NO_ERROR;\n\n#ifdef DAEMON_MODE\n    pkt = GetPktUsingAck(pktSize);\n#else\n    pkt = GetPkt(pktSize);\n#endif\n\n    if (pkt == NULL) {\n        SendResponseStatus(ACTION_ID, NOT_ENOUGH_MEMORY, -1);\n        return(EXT_ERROR);\n    }\n            \n    (void)memcpy(&upInfoIdx, pkt, sizeof(int32_T)); /* Extract upInfoIdx */\n        \n    switch(ACTION_ID) {\n    case EXT_CANCEL_LOGGING_RESPONSE:\n#ifndef EXTMODE_DISABLEPRINTF   \n        PRINT_VERBOSE(\n                (\"got EXT_CANCEL_LOGGING packet for upInfoIdx : %d\\n\", upInfoIdx));\n#endif\n        UploadCancelLogging(upInfoIdx);\n        break;\n    case EXT_ARM_TRIGGER_RESPONSE:\n#ifndef EXTMODE_DISABLEPRINTF\n        PRINT_VERBOSE(\n                (\"got EXT_ARM_TRIGGER packet for upInfoIdx : %d\\n\", upInfoIdx));\n#endif\n        UploadArmTrigger(upInfoIdx, numSampTimes);\n        break;\n    default:\n        break;\n    }\n\n    error = SendResponseStatus(ACTION_ID, STATUS_OK, upInfoIdx);\n    return(error); /* Can be EXT_NO_ERROR */\n} /* end ProcessCancelLoggingArmTriggerPkt */\n#endif /* ifndef EXTMODE_DISABLESIGNALMONITORING */\n\n\n#ifdef EXTMODE_DISABLEPARAMETERTUNING\nPRIVATE boolean_T AcknowledgeSetParamPkt(const int pktSize)\n{\n    int32_T    msg;\n    const char *pkt;\n    boolean_T  error = EXT_NO_ERROR;\n\n    pkt = GetPkt(pktSize);\n    msg = (int32_T)STATUS_OK;\n    error = SendPktToHost(EXT_SETPARAM_RESPONSE, sizeof(int32_T), (char_T *)&msg);\n    return(error);\n}\n#endif /* ifdef EXTMODE_DISABLEPARAMETERTUNING */\n\n#ifdef EXTMODE_DISABLESIGNALMONITORING\nPRIVATE boolean_T AcknowledgeSignalActionPkt(const int pktSize, const ExtModeAction ACTION_ID)\n{\n    const char *pkt;\n    int32_T    upInfoIdx;\n    boolean_T  error = EXT_NO_ERROR;\n\n    pkt = GetPkt(pktSize);\n    (void)memcpy(&upInfoIdx, pkt, sizeof(int32_T));\n    error = SendResponseStatus(ACTION_ID, STATUS_OK, upInfoIdx);\n    return(error);\n} \n#endif /* ifdef EXTMODE_DISABLESIGNALMONITORING */\n\n/*********************\n * Visible Functions *\n *********************/\n\n\n/* Function: ExtParseArgsAndInitUD =============================================\n * Abstract:\n *  Pass remaining arguments (main program should have NULL'ed out any args\n *  that it processed) to external mode.\n *  \n *  The actual, transport-specific parsing routine (implemented in\n *  ext_svr_transport.c) MUST NULL out all entries of argv that it processes.\n *  The main program depends on this in order to determine if any unhandled\n *  command line options were specified (i.e., if the main program detects\n *  any non-null fields after the parse, it throws an error).\n *\n *  Returns an error string on failure, NULL on success.\n *\n * NOTES:\n *  The external mode UserData is created here so that the specified command-\n *  line options can be stored.\n */\nPUBLIC const char_T *ExtParseArgsAndInitUD(const int_T  argc,\n                                           const char_T *argv[])\n{\n    const char_T *error = NULL;\n    \n    /*\n     * Create the user data.\n     */\n    extUD = ExtUserDataCreate();\n    if (extUD == NULL) {\n        error = \"Could not create external mode user data.  Out of memory.\\n\";\n        goto EXIT_POINT;\n    }\n\n    /*\n     * Parse the transport-specific args.\n     */\n    error = ExtProcessArgs(extUD,argc,argv);\n    if (error != NULL) goto EXIT_POINT;\n        \nEXIT_POINT:\n    if (error != NULL) {\n        ExtUserDataDestroy(extUD);\n        extUD = NULL;\n    }\n    return(error);\n} /* end ExtParseArgsAndInitUD */\n\n\n/* Function: ExtWaitForStartPkt ================================================\n * Abstract:\n *  Return true if waiting for host to tell us when to start.\n */\nPUBLIC boolean_T ExtWaitForStartPkt(void)\n{\n    return(ExtWaitForStartPktFromHost(extUD));\n} /* end ExtWaitForStartPkt */\n\n\n#ifndef EXTMODE_DISABLESIGNALMONITORING\n/* Function: UploadServerWork =================================================\n * Abstract:\n *  Upload model signals to host for a single upInfo.\n */\nvoid UploadServerWork(int32_T upInfoIdx, int_T numSampTimes)\n{\n    int_T         i;\n    ExtBufMemList upList;\n    boolean_T     error = EXT_NO_ERROR;\n\n#ifdef VXWORKS\n    /*\n     * Don't spin the CPU unless we've got data to upload.\n     * The upload.c/UploadBufAddTimePoint function gives the sem\n     * each time that data is added.\n     */\ntaskUnsafe();\n    semTake(uploadSem, WAIT_FOREVER);\ntaskSafe();\n#endif\n\n    if (!connected) goto EXIT_POINT;\n    \n    UploadBufGetData(&upList, upInfoIdx, numSampTimes);\n    while(upList.nActiveBufs > 0) {\n        for (i=0; i<upList.nActiveBufs; i++) {\n            const BufMem *bufMem = &upList.bufs[i];\n\n            /*\n             * We call SendPktDataToHost() instead of SendPktToHost() because\n             * the packet header is combined with packet payload.  We do this\n             * to avoid the overhead of making two calls for each upload\n             * packet - one for the head and one for the payload.\n             */\n            error = SendPktDataToHost(\n                bufMem->section1,\n                bufMem->nBytes1);\n            if (error != EXT_NO_ERROR) {\n#ifndef EXTMODE_DISABLEPRINTF                    \n                fprintf(stderr,\"SendPktDataToHost() failed on data upload.\\n\");\n#endif\n                goto EXIT_POINT;\n            }\n            \n            if (bufMem->nBytes2 > 0) {\n\n                error = SendPktDataToHost(\n                    bufMem->section2,\n                    bufMem->nBytes2);\n                if (error != EXT_NO_ERROR) {\n#ifndef EXTMODE_DISABLEPRINTF                        \n                    fprintf(stderr,\"SendPktDataToHost() failed on data upload.\\n\");\n#endif\n                    goto EXIT_POINT;\n                }\n            }\n            /* confirm that the data was sent */\n            UploadBufDataSent(upList.tids[i], upInfoIdx);\n        }\n        UploadBufGetData(&upList, upInfoIdx, numSampTimes);\n    }\n    \nEXIT_POINT:\n    if (error != EXT_NO_ERROR) {\n        /* An error in this function is caused by a physical failure in the\n         * external mode connection.  We assume this failure caused the host\n         * to disconnect.  The target must be disconnected and returned to a\n         * state where it is running and can be re-connected to by the host.\n         */\n        ForceDisconnectFromHost(numSampTimes);\n    }\n}\n/* end UploadServerWork */\n#endif /* ifndef EXTMODE_DISABLESIGNALMONITORING */\n\n#ifndef EXTMODE_DISABLESIGNALMONITORING\n/* Function: rt_UploadServerWork ===============================================\n * Abstract:\n *  Wrapper function that calls UploadServerWork once for each upInfo\n */\nPUBLIC void rt_UploadServerWork(int_T numSampTimes)\n{\n    int i;\n    \n    for (i=0; i<NUM_UPINFOS; i++) {\n        UploadServerWork(i, numSampTimes);\n    }\n} /* end rt_UploadServerWork */\n#endif /* ifndef EXTMODE_DISABLESIGNALMONITORING */\n\n/* Function: rt_ExtModeInit ====================================================\n * Abstract:\n *  Called once at program startup to do any initialization related to external\n *  mode. \n */\nPUBLIC boolean_T rt_ExtModeInit(void)\n{\n    int i;\n    boolean_T error = EXT_NO_ERROR;\n\n#ifdef TMW_EXTMODE_TESTING_REQ\n#  ifndef TMW_EXTMODE_TESTING\n#ifndef EXTMODE_DISABLEPRINTF \n    fprintf(stderr,\"Error: External mode tests should use the external mode test harness.\\n\");\n#endif\n    error = EXT_ERROR;\n#  endif\n#endif\n    if (error != EXT_NO_ERROR) goto EXIT_POINT;\n\n    error = ExtInit(extUD);\n    if (error != EXT_NO_ERROR) goto EXIT_POINT;\n\n    for (i=0; i<NUM_UPINFOS; i++) {\n        UploadLogInfoReset(i);\n    }\n\n    rtExtModeTestingInit();\n\nEXIT_POINT:\n    return(error);\n} /* end rt_ExtModeInit */\n\n\n/* Function: rt_ExtModeSleep ===================================================\n * Abstract:\n *  Called by grt_main, ert_main, and grt_malloc_main  to \"pause\".  It attempts\n *  to do this in a way that does not hog the processor.\n */\n#ifndef VXWORKS\nPUBLIC void rt_ExtModeSleep(\n    long sec,  /* number of seconds to wait       */\n    long usec) /* number of micro seconds to wait */\n{\n    ExtModeSleep(extUD,sec,usec);\n} /* end rt_ExtModeSleep */\n#endif\n\n\n/* Function: rt_PktServerWork ==================================================\n * Abstract:\n *  If not connected, establish communication of the packet line and the\n *  data upload line.  If connected, send/receive packets and parameters\n *  on the packet line.\n */\nPUBLIC void rt_PktServerWork(RTWExtModeInfo *ei,\n                             int_T          numSampTimes,\n                             boolean_T      *stopReq)\n{\n    PktHeader  pktHdr;\n    boolean_T  hdrAvail;\n    boolean_T  error             = EXT_NO_ERROR;\n    boolean_T  disconnectOnError = false;\n    \n    /*\n     * If not connected, attempt to make connection to host.\n     */\n    if (!connected) {\n        rtExtModeTestingKillIfOrphaned(false);\n\n        error = ExtOpenConnection(extUD,&connected);\n        if (error != EXT_NO_ERROR) goto EXIT_POINT;\n    }\n\n    /*\n     * If ExtOpenConnection is not blocking and there are no pending\n     * requests to open a connection, we'll still be unconnected.\n     */\n    if (!connected) goto EXIT_POINT; /* nothing to do */\n    \n    /*\n     * Process packets.\n     */\n\n    /* Wait for a packet. */\n    error = GetPktHdr(&pktHdr, &hdrAvail);\n    if (error != EXT_NO_ERROR) {\n#ifndef EXTMODE_DISABLEPRINTF            \n        fprintf(stderr, \"\\nError occurred getting packet header.\\n\");\n#endif\n        disconnectOnError = true;\n        goto EXIT_POINT;\n    }\n    rtExtModeTestingKillIfOrphaned(hdrAvail);\n    \n    if (!hdrAvail) goto EXIT_POINT; /* nothing to do */\n\n    /*\n     * This is the first packet.  Should contain the string:\n     * 'ext-mode'.  Its contents are not important to us.\n     * It is used as a flag to start the handshaking process.\n     */\n    if (!commInitialized) {\n        pktHdr.type = EXT_CONNECT;\n    }\n\n    /* \n     * At this point we know that we have a packet: process it.\n     */\n#ifdef VXWORKS\n    taskSafe();\n#endif\n    switch(pktHdr.type) {\n\n    case EXT_GET_TIME:\n    {\n        /* Skip verbosity print out - we get too many of these */\n        /*PRINT_VERBOSE((\"got EXT_GET_TIME packet.\\n\"));*/\n        time_T t = rteiGetT(ei);\n        \n        error = SendPktToHost(\n            EXT_GET_TIME_RESPONSE,sizeof(time_T),\n            (char_T *)&t);\n        if (error != EXT_NO_ERROR) goto EXIT_POINT;\n        break;\n    }\n\n    case EXT_ARM_TRIGGER:\n    {\n#ifndef EXTMODE_DISABLESIGNALMONITORING\n        error = ProcessCancelLoggingArmTriggerPkt(EXT_ARM_TRIGGER_RESPONSE, pktHdr.size, numSampTimes);\n        if (error != EXT_NO_ERROR) goto EXIT_POINT;\n#else\n        error = AcknowledgeSignalActionPkt(pktHdr.size, EXT_ARM_TRIGGER_RESPONSE);\n        if (error != EXT_NO_ERROR) goto EXIT_POINT;\n#endif\n        break;\n    }\n\n    case EXT_SELECT_SIGNALS:\n    {\n#ifndef EXTMODE_DISABLESIGNALMONITORING\n        error = ProcessSelectTriggerSignalPkt(EXT_SELECT_SIGNALS_RESPONSE, ei, pktHdr.size, numSampTimes, ERRMSG_PROCESSSELECTSIGNAL);\n        if (error != EXT_NO_ERROR) goto EXIT_POINT;\n#else\n        error = AcknowledgeSignalActionPkt(pktHdr.size, EXT_SELECT_SIGNALS_RESPONSE);\n        if (error != EXT_NO_ERROR) goto EXIT_POINT;\n#endif\n        break;\n    }\n\n    case EXT_SELECT_TRIGGER: \n    {\n#ifndef EXTMODE_DISABLESIGNALMONITORING\n        error = ProcessSelectTriggerSignalPkt(EXT_SELECT_TRIGGER_RESPONSE, ei, pktHdr.size, -1, ERRMSG_PROCESSSELECTTRIGGER);\n        if (error != EXT_NO_ERROR) goto EXIT_POINT;\n#else\n        error = AcknowledgeSignalActionPkt(pktHdr.size, EXT_SELECT_TRIGGER_RESPONSE);\n        if (error != EXT_NO_ERROR) goto EXIT_POINT;\n#endif\n        break;\n    }\n\n    case EXT_CONNECT:\n    {\n        PRINT_VERBOSE((\"got EXT_CONNECT packet.\\n\"));\n        error = ProcessConnectPkt(ei);\n        if (error != EXT_NO_ERROR) goto EXIT_POINT;\n        break;\n    }\n\n    case EXT_SETPARAM:\n    {\n#ifndef EXTMODE_DISABLEPARAMETERTUNING\n        PRINT_VERBOSE((\"got EXT_SETPARAM packet.\\n\"));\n        if (pktHdr.size == 0) {\n            gblSetParamPktReceived = true;\n        } else {\n            error = ProcessSetParamPkt(ei, pktHdr.size);\n            if (error != EXT_NO_ERROR) {\n                goto EXIT_POINT;\n            }\n            else {\n                gblSetParamPktReceived = true;\n            }\n        }\n#else\n        PRINT_VERBOSE((\"discard EXT_SETPARAM packet.\\n\"));\n        error = AcknowledgeSetParamPkt(pktHdr.size);\n        if (error != EXT_NO_ERROR) goto EXIT_POINT;\n#endif\n        break;\n    }\n\n    case EXT_GETPARAMS:\n    {\n#ifndef EXTMODE_DISABLEPARAMETERTUNING\n        PRINT_VERBOSE((\"got EXT_GETPARAMS packet.\\n\"));\n        error = ProcessGetParamsPkt(ei);\n        if (error != EXT_NO_ERROR) goto EXIT_POINT;\n#endif\n        break;\n    }\n\n    case EXT_DISCONNECT_REQUEST:\n    {\n        PRINT_VERBOSE((\"got EXT_DISCONNECT_REQUEST packet.\\n\"));\n        \n        /*\n         * Note that from the target's point of view this is\n         * more a \"notify\" than a \"request\".  The host needs to\n         * have this acknowledged before it can begin closing\n         * the connection.\n         */\n        error = SendPktToHost(EXT_DISCONNECT_REQUEST_RESPONSE, 0, NULL);\n        if (error != EXT_NO_ERROR) goto EXIT_POINT;\n\n        DisconnectFromHost(numSampTimes);\n\n        break;\n    }\n\n    case EXT_DISCONNECT_REQUEST_NO_FINAL_UPLOAD:\n    {\n        PRINT_VERBOSE((\"got EXT_DISCONNECT_REQUEST_NO_FINAL_UPLOAD packet.\\n\"));\n        \n        /*\n         * The target receives this packet when the host is\n         * immediately terminating the extmode communication due\n         * to some error.  The target should not send back a\n         * response or a final upload of data because the host is\n         * expecting neither.  The target must be disconnected and\n         * returned to a state where it is running and can be\n         * re-connected to by the host.\n         */\n        ForceDisconnectFromHost(numSampTimes);\n\n        break;\n    }\n\n    case EXT_MODEL_START:\n        PRINT_VERBOSE((\"got EXT_MODEL_START packet.\\n\"));\n#ifdef VXWORKS\n        {\n            extern SEM_ID startStopSem;\n            semGive(startStopSem);\n        }\n#endif\n        startModel = true;\n        error = SendPktToHost(EXT_MODEL_START_RESPONSE, 0, NULL);\n        if (error != EXT_NO_ERROR) goto EXIT_POINT;\n        break;\n\n    case EXT_MODEL_STOP:\n        PRINT_VERBOSE((\"got EXT_MODEL_STOP packet.\\n\"));\n        *stopReq = true;\n        break;\n#ifndef EXTMODE_DISABLETESTING\n    case EXT_MODEL_PAUSE:\n        PRINT_VERBOSE((\"got EXT_MODEL_PAUSE packet.\\n\"));\n        modelStatus = TARGET_STATUS_PAUSED;\n        startModel  = false;\n\n        error = SendPktToHost(EXT_MODEL_PAUSE_RESPONSE, 0, NULL);\n        if (error != EXT_NO_ERROR) goto EXIT_POINT;\n        break;\n    case EXT_MODEL_STEP:\n        PRINT_VERBOSE((\"got EXT_MODEL_STEP packet.\\n\"));\n        if ((modelStatus == TARGET_STATUS_PAUSED) && !startModel) {\n            startModel = true;\n        }\n        \n        error = SendPktToHost(EXT_MODEL_STEP_RESPONSE, 0, NULL);\n        if (error != EXT_NO_ERROR) goto EXIT_POINT;\n        break;\n    case EXT_MODEL_CONTINUE:\n        PRINT_VERBOSE((\"got EXT_MODEL_CONTINUE packet.\\n\"));\n        if (modelStatus == TARGET_STATUS_PAUSED) {\n            modelStatus = TARGET_STATUS_RUNNING;\n            startModel  = false;\n        }\n        \n        error = SendPktToHost(EXT_MODEL_CONTINUE_RESPONSE, 0, NULL);\n        if (error != EXT_NO_ERROR) goto EXIT_POINT;\n#endif\n        break;\n\n    case EXT_CANCEL_LOGGING:\n    {\n#ifndef EXTMODE_DISABLESIGNALMONITORING\n        error = ProcessCancelLoggingArmTriggerPkt(EXT_CANCEL_LOGGING_RESPONSE, pktHdr.size, numSampTimes);\n        if (error != EXT_NO_ERROR) goto EXIT_POINT;\n#else\n        error = AcknowledgeSignalActionPkt(pktHdr.size, EXT_CANCEL_LOGGING_RESPONSE);\n        if (error != EXT_NO_ERROR) goto EXIT_POINT;\n#endif\n        break;\n    }\n\n    default:\n#ifndef EXTMODE_DISABLEPRINTF            \n        fprintf(stderr,\"received invalid packet.\\n\");\n#endif\n        break;\n    } /* end switch */\n\nEXIT_POINT:\n    if (error != EXT_NO_ERROR) {\n        if (disconnectOnError) {\n#ifndef EXTMODE_DISABLEPRINTF                \n            fprintf(stderr,\n                \"Error occurred in rt_PktServerWork.\\n\"\n                \"Disconnecting from host!\\n\");\n#endif\n            /* An error in this function which causes disconnectOnError to be\n             * set to true is caused by a physical failure in the external mode\n             * connection.  We assume this failure caused the host to disconnect.\n             * The target must be disconnected and returned to a state\n             * where it is running and can be re-connected to by the host.\n             */\n            ForceDisconnectFromHost(numSampTimes);\n        }\n    }\n#ifdef VXWORKS\n    taskUnsafe();\n#endif\n} /* end rt_PktServerWork */\n\n\n/* Function: rt_PktServer ======================================================\n * Abstract:\n *  Call rt_PktServerWork forever.   Used only for RTOS (e.g., Tornado/VxWorks\n *  when running as a low priority task.\n */\n#ifdef VXWORKS\nPUBLIC void rt_PktServer(RTWExtModeInfo *ei,\n                         int_T          numSampTimes,\n                         boolean_T      *stopReq)\n{\n    for(;;) {\n        rt_PktServerWork(ei,numSampTimes,stopReq); \n    }\n}\n#endif\n\n\n/* Function: rt_UploadServer ===================================================\n * Abstract:\n *  Call rt_UploadServerWork forever.   Used only for RTOS (e.g.,\n *  Tornado/VxWorks when running as a low priority task.\n */\n#ifdef VXWORKS\n#ifndef EXTMODE_DISABLESIGNALMONITORING\nPUBLIC void rt_UploadServer(int_T numSampTimes)\n{\n    for(;;) {\n        rt_UploadServerWork(numSampTimes);\n    }\n} /* end rt_UploadServer */\n#endif /* ifndef EXTMODE_DISABLESIGNALMONITORING */\n#endif\n\n\n/* Function: rt_SetPortInExtUD =================================================\n * Abstract:\n *  Set the port in the external mode user data structure.\n */\n#ifdef VXWORKS\nPUBLIC void rt_SetPortInExtUD(const int_T port)\n{\n    ExtUserDataSetPort(extUD, port);\n} /* end rt_SetPortInExtUD */\n#endif\n\n/* Function: ExtModeShutdown ==================================================\n * Abstract:\n *  Called when target program terminates to enable cleanup of external \n *  mode for a given upInfo.\n */\nPRIVATE void ExtModeShutdown(int32_T upInfoIdx, int_T numSampTimes)\n{\n    /*\n     * Make sure buffers are flushed so that the final points get to\n     * host (this is important for the case of the target reaching tfinal\n     * while data uploading is in progress).\n     */\n    UploadPrepareForFinalFlush(upInfoIdx);\n#ifndef EXTMODE_DISABLESIGNALMONITORING\n    UploadServerWork(upInfoIdx, numSampTimes);\n#endif\n\n    UploadLogInfoTerm(upInfoIdx, numSampTimes);\n\n    if (pktBuf != NULL) {\n        free(pktBuf);\n        pktBuf = NULL;\n    }\n\n} /* end ExtModeShutdown */\n\n/* Function: rt_ExtModeShutdown ================================================\n * Abstract:\n *  Called when target program terminates to enable cleanup of external \n *  mode.\n */\nPUBLIC boolean_T rt_ExtModeShutdown(int_T numSampTimes)\n{\n    int i;\n    boolean_T error = EXT_NO_ERROR;\n\n    for (i=0; i<NUM_UPINFOS; i++) {\n        ExtModeShutdown(i, numSampTimes);\n    }\n\n    if (commInitialized) {\n        error = SendPktToHost(EXT_MODEL_SHUTDOWN, 0, NULL);\n        if (error != EXT_NO_ERROR) {\n#ifndef EXTMODE_DISABLEPRINTF                \n            fprintf(stderr,\n                \"\\nError sending EXT_MODEL_SHUTDOWN packet to host.\\n\");\n#endif\n        }\n        commInitialized = false;\n    }\n    if (connected) {\n        connected = false;\n        modelStatus = TARGET_STATUS_WAITING_TO_START;        \n    }\n\n    ExtShutDown(extUD);\n    ExtUserDataDestroy(extUD);\n    \n    rtExtModeTestingRemoveBatMarker();\n    \n    return(error);\n} /* end rt_ExtModeShutdown */\n\n#ifndef EXTMODE_DISABLESIGNALMONITORING\n/* Function: rt_UploadCheckTrigger =============================================\n * Abstract:\n *  Wrapper function that calls UploadCheckTrigger once for each upInfo\n */\nPUBLIC void rt_UploadCheckTrigger(int_T numSampTimes)\n{\n    int i;\n    for (i=0; i<NUM_UPINFOS; i++) {\n        UploadCheckTrigger(i, numSampTimes);\n    }\n} /* end rt_UploadCheckTrigger */\n\n/* Function: rt_UploadCheckEndTrigger ==========================================\n * Abstract:\n *  Wrapper function that calls UploadCheckTrigger once for each upInfo\n */\nPUBLIC void rt_UploadCheckEndTrigger(void)\n{\n    int i;\n    \n    for (i=0; i<NUM_UPINFOS; i++) {\n        UploadCheckEndTrigger(i);\n    }\n} /* end rt_UploadCheckEndTrigger */\n\n/* Function: rt_UploadBufAddTimePoint ==========================================\n * Abstract:\n *  Wrapper function that calls UploadBufAddTimePoint once for each upInfo\n */\nPUBLIC void rt_UploadBufAddTimePoint(int_T tid, real_T taskTime)\n{\n    int i;\n    \n    for (i=0; i<NUM_UPINFOS; i++) {\n        UploadBufAddTimePoint(tid, taskTime, i);\n    }\n} /* end rt_UploadBufAddTimePoint */\n#endif /* ifndef EXTMODE_DISABLESIGNALMONITORING */\n\n/* [EOF] ext_svr.c */\n"},{"name":"ext_work.c","type":"source","group":"legacy","path":"D:\\Program Files\\MATLAB\\R2023a\\rtw\\c\\src\\ext_mode\\common","tag":"","groupDisplay":"其他文件","code":"/*\n * Copyright 1994-2021 The MathWorks, Inc.\n *\n * File: ext_work.c     \n *\n * Abstract:\n *   \n */\n\n#if !defined(EXTMODE_DISABLEPRINTF) || !defined(EXTMODE_DISABLE_ARGS_PROCESSING)\n#include <stdio.h>\n#endif\n\n#include <stdlib.h>        /* for exit() */\n#include <string.h>        /* optional for strcmp */\n\n#include \"rtwtypes.h\"\n#include \"rtw_extmode.h\"\n\n#include \"ext_types.h\"\n#include \"ext_share.h\"\n#include \"updown.h\"\n#include \"ext_svr.h\"\n#include \"ext_svr_transport.h\"\n#include \"ext_work.h\" /* includes all VxWorks headers */\n\n/* Logical definitions */\n#if (!defined(__cplusplus))\n#  ifndef false\n#   define false                       (0U)\n#  endif\n#  ifndef true\n#   define true                        (1U)\n#  endif\n#endif\n\nint_T           volatile startModel  = false;\nTargetSimStatus volatile modelStatus = TARGET_STATUS_WAITING_TO_START;\n\n#ifdef VXWORKS\nSEM_ID volatile uploadSem = NULL;\nSEM_ID volatile commSem   = NULL;\nSEM_ID volatile pktSem    = NULL;\nint_T           extern_pkt_tid;\nint_T           extern_upload_tid;\n\nvoid rtExtModeTornadoStartup(RTWExtModeInfo *ei,\n                             int_T          numSampTimes,\n                             boolean_T      *stopReqPtr,\n                             int_T          priority,\n                             int32_T        stack_size,\n                             SEM_ID         startStopSem)\n{\n    uploadSem = semBCreate(SEM_Q_PRIORITY, SEM_EMPTY);\n    commSem   = semBCreate(SEM_Q_PRIORITY, SEM_FULL);\n    pktSem    = semBCreate(SEM_Q_PRIORITY, SEM_FULL);\n\n    rt_ExtModeInit();\n\n    extern_pkt_tid = taskSpawn(\"tExternPkt\",\n        priority+(numSampTimes), VX_FP_TASK, stack_size, (FUNCPTR)rt_PktServer, \n        (int_T) ei, (int_T) numSampTimes, (int_T) stopReqPtr, 0, 0, 0, 0, 0, 0, 0);\n    if (extern_pkt_tid == ERROR) {\n#ifndef EXTMODE_DISABLEPRINTF\n        printf(\"handle taskpawn error\");\n#endif\n    }\n\n    extern_upload_tid = taskSpawn(\"tExternUpload\",\n        priority+(numSampTimes)+1,VX_FP_TASK, stack_size,(FUNCPTR)rt_UploadServer,\n        (int_T) numSampTimes, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n    if (extern_upload_tid == ERROR) {\n#ifndef EXTMODE_DISABLEPRINTF\n        printf(\"handle taskpawn error\");\n#endif\n    }\n\n    /*\n     * Pause until receive model start packet - if external mode.\n     * Make sure the external mode tasks are running so that \n     * we are listening for commands from the host.\n     */\n    if (ExtWaitForStartPkt()) {\n#ifndef EXTMODE_DISABLEPRINTF\n        printf(\"\\nWaiting for start packet from host.\\n\");\n#endif\n        semTake(startStopSem, WAIT_FOREVER);\n    }\n    modelStatus = TARGET_STATUS_RUNNING;\n}\n\nvoid rtExtModeTornadoCleanup(int_T numSampTimes)\n{\n    taskDelete(extern_upload_tid);\n    taskDelete(extern_pkt_tid);\n    rt_ExtModeShutdown(numSampTimes);\n    semDelete(uploadSem);\n    semDelete(commSem);\n    semDelete(pktSem);\n}\n\n/* Function ====================================================================\n *  Used by Tornado/VxWorks to set the port number used by external mode.\n *  Tornado does not parse the port number the same way as the other code\n *  formats.  Instead, the port number is specified as an argument to the\n *  spawn command which passes it into rt_main().  This function is called\n *  by rt_main() to set the port number in the external mode user data\n *  structure.\n */\nvoid rtExtModeTornadoSetPortInExtUD(const int_T port)\n{\n    rt_SetPortInExtUD(port);\n}\n\n#else /* VXWORKS == 0 */\n\n/* Function ====================================================================\n * Pause the process (w/o hogging the cpu) until receive step packet (which\n * means the startModel flag moves to true) or until we are no longer\n * in the paused state.  The packet/upload server must continue to process\n * events (otherwise the host would not be able to communicate with the target).\n */\nvoid rtExtModePauseIfNeeded(RTWExtModeInfo *ei,\n                            int_T          numSampTimes,\n                            boolean_T      *stopReqPtr)\n{\n    while((modelStatus == TARGET_STATUS_PAUSED) && \n          !startModel && !(*stopReqPtr)) {\n        rt_ExtModeSleep(0L, 375000L);\n        rt_PktServerWork(ei,numSampTimes,stopReqPtr);\n#ifndef EXTMODE_DISABLESIGNALMONITORING\n        rt_UploadServerWork(numSampTimes);\n#endif\n    }\n    startModel = false; /* reset to false - if we were stepped we want to\n                         *                  stop again next time we get\n                         *                  back here.\n                         */\n} /* end rtExtModePauseIfNeeded */\n\n/* Function ====================================================================\n * Pause the process (w/o hogging the cpu) until receive start packet\n * from the host.  The packet/upload server must continue to process\n * events (otherwise the host would not be able to communicate with the target).\n */\nvoid rtExtModeWaitForStartPkt(RTWExtModeInfo *ei,\n                              int_T          numSampTimes,\n                              boolean_T      *stopReqPtr)\n{\n    /*\n     * Pause until receive model start packet.\n     */\n    if (ExtWaitForStartPkt()) {\n        while(!startModel && !(*stopReqPtr)) {\n            rt_ExtModeSleep(0L, 375000L);\n            rt_PktServerWork(ei,numSampTimes,stopReqPtr);\n#ifndef EXTMODE_DISABLESIGNALMONITORING\n            rt_UploadServerWork(numSampTimes);\n#endif\n        }\n    }\n    if (modelStatus != TARGET_STATUS_PAUSED) {\n        modelStatus = TARGET_STATUS_RUNNING;\n    } else {\n        /* leave in pause mode */\n    }\n}\n#endif\n\nvoid rtExtModeOneStep(RTWExtModeInfo *ei,\n                      int_T          numSampTimes,\n                      boolean_T      *stopReqPtr)\n{\n    /*\n     * In a multi-tasking environment, this would be removed from the base rate\n     * and called as a \"background\" task.\n     */\n    if (modelStatus != TARGET_STATUS_PAUSED) {\n        rt_PktServerWork(ei,numSampTimes,stopReqPtr);\n#ifndef EXTMODE_DISABLESIGNALMONITORING\n        rt_UploadServerWork(numSampTimes);\n#endif\n    }\n}\n\nvoid rtExtModeUpload(int_T tid, real_T taskTime)\n{\n#ifndef EXTMODE_DISABLESIGNALMONITORING\n    rt_UploadBufAddTimePoint(tid, taskTime);\n#endif\n}\n\nvoid rtExtModeCheckEndTrigger(void)\n{\n#ifndef EXTMODE_DISABLESIGNALMONITORING\n    rt_UploadCheckEndTrigger();\n#endif\n}\n\nvoid rtExtModeUploadCheckTrigger(int_T numSampTimes)\n{\n#ifndef EXTMODE_DISABLESIGNALMONITORING\n    rt_UploadCheckTrigger(numSampTimes);\n#endif\n}\n\nvoid rtExtModeCheckInit(int_T numSampTimes)\n{\n    UNUSED_PARAMETER(numSampTimes);\n    if (rt_ExtModeInit() != EXT_NO_ERROR){\n#ifndef EXTMODE_DISABLEPRINTF            \n            printf(\"Error calling rt_ExtModeInit!\\n\");\n            exit(EXIT_FAILURE);         /*Error out if rt_ExtModeInit() returns EXT_ERROR. */\n#endif\n    }\n}\n\nvoid rtExtModeShutdown(int_T numSampTimes)\n{\n    rt_ExtModeShutdown(numSampTimes);\n}\n\nvoid rtExtModeParseArgs(int_T        argc, \n                        const char_T *argv[],\n                        real_T       *unused)\n{\n    UNUSED_PARAMETER(unused);\n\n#ifdef  EXTMODE_DISABLE_ARGS_PROCESSING\n    /* Some targets do not support command line args, so bypass the args \n     * processing and directly call into ExtParseArgsAndInitUD.\n     */\n\n    /* initialize external mode */\n    ExtParseArgsAndInitUD(0, NULL);\n\n#else   \n\n    /*\n     * Parse the external mode arguments.\n     */\n    {\n        const char_T *extParseErrorPkt = ExtParseArgsAndInitUD(argc, argv);\n        if (extParseErrorPkt != NULL) {\n#ifndef EXTMODE_DISABLEPRINTF            \n            printf(\n                \"\\nError processing External Mode command line arguments:\\n\");\n            printf(\"\\t%s\",extParseErrorPkt);\n#endif\n            exit(EXIT_FAILURE);\n        }\n    }\n#endif  /* EXTMODE_DISABLE_ARGS_PROCESSING */\n}\n\n/* Start of ERT specific functions and data */\n\n#ifndef EXTMODE_DISABLE_ARGS_PROCESSING\nstatic void displayUsage(void)\n{\n#ifndef EXTMODE_DISABLEPRINTF    \n    (void) printf(\"usage: model_name -tf <finaltime> -w -port <TCPport>\\n\");\n    (void) printf(\"arguments:\\n\");\n    (void) printf(\"  -tf <finaltime> - overrides final time specified in \"\n                  \"Simulink (inf for no limit).\\n\");\n    (void) printf(\"  -w              - waits for Simulink to start model \"\n                  \"in External Mode.\\n\");\n    (void) printf(\"  -port <TCPport> - overrides 17725 default port in \"\n                  \"External Mode, valid range 256 to 65535.\\n\");\n#endif    \n}\n#endif\n\nstatic const real_T RUN_FOREVER = (real_T)-1;\n#if INTEGER_CODE == 0\nstatic real_T finaltime = (real_T)-2; /* default to stop time in Sim Params. */\n#else\nstatic real_T finaltime = (real_T)-1; /* default to stop time inf */\n#endif\n\nvoid rtERTExtModeSetTFinal(real_T *rtmTFinal)\n{\n    if (finaltime >= (real_T)0 || finaltime == RUN_FOREVER) {\n        *rtmTFinal = finaltime;\n    }\n}\n\nvoid rtSetTFinalForExtMode(real_T *rtmTFinal)\n{\n    rtERTExtModeSetTFinal(rtmTFinal);\n}\n\nvoid rtParseArgsForExtMode(int_T        argc, \n                           const char_T *argv[])\n{\n\n#ifdef  EXTMODE_DISABLE_ARGS_PROCESSING\n    /* Some targets do not support command line args, so bypass the args \n     * processing and directly call into ExtParseArgsAndInitUD.\n     */\n\n    /* initialize external mode */\n    ExtParseArgsAndInitUD(0, NULL);\n\n#else    \n    /* parse command line args */\n\n    int_T  oldStyle_argc;\n    const char_T *oldStyle_argv[5];\n\n    if ((argc > 1) && (argv[1][0] != '-')) {\n        /* at least one command line argument has been provided without\n           specifying an option with '-', using the old style */\n        if ( argc > 3 ) {\n            displayUsage();\n            exit(EXIT_FAILURE);\n        }\n\n        /* using the old style the first argument is always the final time */\n        oldStyle_argc = 3;\n        oldStyle_argv[0] = argv[0];\n        oldStyle_argv[1] = \"-tf\";\n        oldStyle_argv[2] = argv[1];\n\n        if (argc == 3) {\n            oldStyle_argc = 5;\n\n            oldStyle_argv[3] = \"-port\";\n            oldStyle_argv[4] = argv[2];\n\n        }\n\n        argc = oldStyle_argc;\n        argv = oldStyle_argv;\n\n    }\n\n    {\n        /* new style: */\n        double    tmpDouble;\n        char_T tmpStr2[200];\n        int_T  count      = 1;\n        int_T  parseError = false;\n\n        /*\n         * Parse the standard RTW parameters.  Let all unrecognized parameters\n         * pass through to external mode for parsing.  NULL out all args handled\n         * so that the external mode parsing can ignore them.\n         */\n        while(count < argc) {\n            const char_T *option = argv[count++];\n            \n            /* final time */\n            if ((strcmp(option, \"-tf\") == 0) && (count != argc)) {\n                const char_T *tfStr = argv[count++];\n                \n                sscanf(tfStr, \"%200s\", tmpStr2);\n                if (strcmp(tmpStr2, \"inf\") == 0) {\n                    tmpDouble = RUN_FOREVER;\n                } else {\n                    char_T tmpstr[2];\n\n#if INTEGER_CODE == 0\n                    if ( (sscanf(tmpStr2,\"%lf%1s\", &tmpDouble, tmpstr) != 1) ||\n                         (tmpDouble < (real_T)0) ) {\n    #ifndef EXTMODE_DISABLEPRINTF\n                        (void)printf(\"finaltime must be a positive, real value or inf\\n\");\n    #endif\n                        parseError = true;\n                        break;\n                    }\n#else\n                    if ( (sscanf(tmpStr2,\"%d%1s\", &tmpDouble, tmpstr) != 1) ||\n                         (tmpDouble < (real_T)0) ) {\n    #ifndef EXTMODE_DISABLEPRINTF\n                        (void)printf(\"tmpDouble = %d\\n\", tmpDouble);\n                        (void)printf(\"finaltime must be a positive, integer value or inf\\n\");\n    #endif\n                        parseError = true;\n                        break;\n                    }\n#endif\n                }\n                finaltime = (real_T) tmpDouble;\n\n                argv[count-2] = NULL;\n                argv[count-1] = NULL;\n            }\n        }\n\n        if (parseError) {\n    #ifndef EXTMODE_DISABLEPRINTF        \n            (void)printf(\"\\nUsage: model_name -option1 val1 -option2 val2 -option3 \"\n                         \"...\\n\\n\");\n            (void)printf(\"\\t-tf 20 - sets final time to 20 seconds\\n\");\n    #endif        \n\n            exit(EXIT_FAILURE);\n        }\n\n        /*\n         * Parse the external mode arguments.\n         */\n        {\n            const char_T *extParseErrorPkt = ExtParseArgsAndInitUD(argc, argv);\n            if (extParseErrorPkt != NULL) {\n    #ifndef EXTMODE_DISABLEPRINTF           \n                printf(\n                    \"\\nError processing External Mode command line arguments:\\n\");\n                printf(\"\\t%s\",extParseErrorPkt);\n    #endif\n                exit(EXIT_FAILURE);\n            }\n        }\n\n        /*\n         * Check for unprocessed (\"unhandled\") args.\n         */\n        {\n            int i;\n            for (i=1; i<argc; i++) {\n                if (argv[i] != NULL) {\n    #ifndef EXTMODE_DISABLEPRINTF                \n                    printf(\"Unexpected command line argument: %s\\n\",argv[i]);\n    #endif\n                    exit(EXIT_FAILURE);\n                }\n            }\n        }\n    }\n\n    if (finaltime == RUN_FOREVER) {\n        #ifndef EXTMODE_DISABLEPRINTF\n                printf (\"\\n**warning: the simulation will run with no stop time due \"\n                \"to external mode with '-tf inf' argument.\\n\");\n        #endif\n    }\n\n#endif /* EXTMODE_DISABLE_ARGS_PROCESSING */\n}\n\nvoid rtERTExtModeStartMsg(void)\n{\n#ifndef EXTMODE_DISABLEPRINTF    \n    (void)printf(\"\\n** starting the model **\\n\");\n#endif\n}\n\n/* End of ERT specific functions and data */\n\n/* [EOF] ext_work.c */\n"},{"name":"main.c","type":"source","group":"","path":"E:\\DR_Han\\小人形关节整合\\controller\\RL\\LED_MBD_stm32","tag":"","groupDisplay":"其他文件","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: main.c\r\n *\r\n * Code generated for Simulink model :LED_MBD.\r\n *\r\n * Model version      : 1.14\r\n * Simulink Coder version    : 9.9 (R2023a) 19-Nov-2022\r\n * TLC version       : 9.9 (Nov  8 2023)\r\n * C/C++ source code generated on  : Sat Nov  9 16:29:02 2024\r\n *\r\n * Target selection: stm32.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n *\r\n *\r\n *\r\n * ******************************************************************************\r\n * * attention\r\n * *\r\n * * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS\r\n * * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE\r\n * * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY\r\n * * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING\r\n * * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE\r\n * * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.\r\n * *\r\n * ******************************************************************************\r\n */\r\n\r\n/* This section of code is going to be merged by the STM32CubeMX tool. */\r\n/* USER CODE BEGIN 0 */\r\n#include <stdio.h>\r\n#include \"LED_MBD.h\"\r\n#include \"rtwtypes.h\"\r\n#include \"multiword_types.h\"\r\n#include \"ext_work.h\"\r\n\r\n/* Flags for taskOverrun */\r\nstatic boolean_T OverrunFlags[1];\r\n\r\n/* Number of auto reload timer rotation computed */\r\nstatic volatile uint32_t autoReloadTimerLoopVal_S = 1;\r\n\r\n/* Remaining number of auto reload timer rotation to do */\r\nvolatile uint32_t remainAutoReloadTimerLoopVal_S = 1;\r\n\r\n/* USER CODE END 0 */\r\n\r\n/**\r\n * @brief  The application entry point.\r\n * @retval int\r\n */\r\nint main (void)\r\n{\r\n  /* This section of code is going to be merged by the STM32CubeMX tool. */\r\n  /* USER CODE BEGIN 1 */\r\n  /* USER CODE END 1 */\r\n\r\n  /* This section of code is going to be merged by the STM32CubeMX tool. */\r\n  /* USER CODE BEGIN 2 */\r\n\r\n  /* Use Systick arm timer and interrupt to tick step() functions of the Simulink model. */\r\n  /* Fundamental sample time is set to: '0.001000000' s */\r\n  if (SysTick_Config((uint32_t)(SystemCoreClock / 1000.0))) {\r\n    autoReloadTimerLoopVal_S = 1;\r\n    do {\r\n      autoReloadTimerLoopVal_S++;\r\n    } while ((uint32_t)(SystemCoreClock/1000.0)/autoReloadTimerLoopVal_S >\r\n             SysTick_LOAD_RELOAD_Msk);\r\n\r\n    SysTick_Config((uint32_t)(SystemCoreClock/1000.0)/autoReloadTimerLoopVal_S);\r\n  }\r\n\r\n  /* Set number of loop to do. */\r\n  remainAutoReloadTimerLoopVal_S = autoReloadTimerLoopVal_S;\r\n\r\n  {\r\n    int i;\r\n    for (i = 0; i < 1; i++) {\r\n      OverrunFlags[i] = false;\r\n    }\r\n  }\r\n\r\n  /* initialize external mode */\r\n  rtParseArgsForExtMode(0, NULL);\r\n\r\n  /* Initialize model */\r\n  LED_MBD_initialize();\r\n\r\n  /* External mode */\r\n  rtSetTFinalForExtMode(&rtmGetTFinal(LED_MBD_M));\r\n  rtExtModeCheckInit(1);\r\n\r\n  {\r\n    boolean_T rtmStopReq = false;\r\n    rtExtModeWaitForStartPkt(LED_MBD_M->extModeInfo, 1, &rtmStopReq);\r\n    if (rtmStopReq) {\r\n      rtmSetStopRequested(LED_MBD_M, true);\r\n    }\r\n  }\r\n\r\n  rtERTExtModeStartMsg();\r\n\r\n  /* USER CODE END 2 */\r\n\r\n  /* This section of code is going to be merged by the STM32CubeMX tool. */\r\n  /* USER CODE BEGIN WHILE */\r\n  /* Infinite loop */\r\n  /* Real time from systickHandler */\r\n  while (1) {\r\n    /* Process tasks every solver time */\r\n    if (remainAutoReloadTimerLoopVal_S == 0) {\r\n      remainAutoReloadTimerLoopVal_S = autoReloadTimerLoopVal_S;\r\n\r\n      /* Check base rate for overrun */\r\n      if (OverrunFlags[0]) {\r\n        rtmSetErrorStatus(LED_MBD_M, \"Overrun\");\r\n      }\r\n\r\n      OverrunFlags[0] = true;\r\n\r\n      /* External mode */\r\n      {\r\n        boolean_T rtmStopReq = false;\r\n        rtExtModeOneStep(LED_MBD_M->extModeInfo, 1, &rtmStopReq);\r\n        if (rtmStopReq) {\r\n          rtmSetStopRequested(LED_MBD_M, true);\r\n        }\r\n      }\r\n\r\n      /* Step the model for base rate */\r\n      LED_MBD_step();\r\n\r\n      /* Get model outputs here */\r\n\r\n      /* Indicate task for base rate complete */\r\n      OverrunFlags[0] = false;\r\n    }\r\n  }\r\n\r\n  /* USER CODE END WHILE */\r\n\r\n  /* USER CODE BEGIN 3 */\r\n  /* USER CODE END 3 */\r\n}\r\n\r\n/* File trailer for Real-Time Workshop generated code.\r\n *\r\n * [EOF] main.c\r\n */\r\n"},{"name":"stm32xxxx_it.c","type":"source","group":"","path":"E:\\DR_Han\\小人形关节整合\\controller\\RL\\LED_MBD_stm32","tag":"","groupDisplay":"其他文件","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: stm32xxxx_it.c\r\n *\r\n * Code generated for Simulink model :LED_MBD.\r\n *\r\n * Model version      : 1.14\r\n * Simulink Coder version    : 9.9 (R2023a) 19-Nov-2022\r\n * TLC version       : 9.9 (Nov  8 2023)\r\n * C/C++ source code generated on  : Sat Nov  9 16:29:02 2024\r\n *\r\n * Target selection: stm32.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n *\r\n *\r\n *\r\n * ******************************************************************************\r\n * * attention\r\n * *\r\n * * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS\r\n * * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE\r\n * * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY\r\n * * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING\r\n * * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE\r\n * * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.\r\n * *\r\n * ******************************************************************************\r\n */\r\n\r\n/**\r\n * @brief This function handles System tick timer.\r\n */\r\nvoid SysTick_Handler(void)\r\n{\r\n  /* This section of code is going to be merged by the STM32CubeMX tool. */\r\n  /* USER CODE BEGIN SysTick_IRQn 0 */\r\n  {\r\n    extern volatile uint32_t remainAutoReloadTimerLoopVal_S;\r\n\r\n    /* Manage number of loop before interrupt has to be processed. */\r\n    if (remainAutoReloadTimerLoopVal_S) {\r\n      remainAutoReloadTimerLoopVal_S--;\r\n    }\r\n  }\r\n\r\n  /* USER CODE END SysTick_IRQn 0 */\r\n\r\n  /* USER CODE BEGIN SysTick_IRQn 1 */\r\n\r\n  /* USER CODE END SysTick_IRQn 1 */\r\n}\r\n\r\n/* File trailer for Real-Time Workshop generated code.\r\n *\r\n * [EOF] stm32xxxx_it.c\r\n */\r\n"},{"name":"updown.c","type":"source","group":"legacy","path":"D:\\Program Files\\MATLAB\\R2023a\\rtw\\c\\src\\ext_mode\\common","tag":"","groupDisplay":"其他文件","code":"/*\n * Copyright 1994-2020 The MathWorks, Inc.\n */\n#include <stdlib.h>\n#include <string.h>\n\n/*Real Time Workshop headers*/\n#include \"rtwtypes.h\"\n#include \"rtw_extmode.h\"\n#include \"sysran_types.h\"\n\n/* \n * String is dynamic in the following cases\n * - Rapid Accelerator mode\n */\n#ifdef IS_RAPID_ACCEL\n#define MW_DYNAMIC_STRING_SUPPORT\n#endif\n\n#ifdef MW_DYNAMIC_STRING_SUPPORT\n#include \"mwstringutil.h\"\n/* \"assert\" is defined in updown_util.h below */ \n#undef assert\n#endif\n\n/* \n * Note: Local headers should be after external headers\n *       Otherwise, some macros may be re-defined\n *       One example is \"assert\" in updown_util.h\n *       mwstringutil.h inderectly re-define it\n */\n#include \"ext_types.h\"\n#include \"ext_share.h\"\n#include \"ext_svr.h\"\n#include \"ext_work.h\"\n#include \"updown_util.h\"\n#include \"dt_info.h\"\n\n/* DUMP_PKT is defined to be (0) below - why? See g2176068. */\n#if defined(VERBOSE) || (defined(DUMP_PKT) && DUMP_PKT)\n#include <stdio.h>\n#endif\n\n/* \n * Depending on the target's native word size and pointer size, interrupts\n * might need to be disabled around critical regions when accessing the \n * the external mode circular buffer. If, for example, reading a pointer \n * is not guaranteed to be an atomic operation on your target, then you  \n * need to define the preprocessor defines below to prevent interrupts  \n * around the critical regions.\n * \n * Here is a description of each of these preprocessor defines:\n * EXTMODE_PROTECT_CRITICAL_REGIONS: this should be defined if interrupts \n *      should be disabled around critical regions\n * EXTMODE_INTERRUPT_INC_HDR: this defines the include header file \n *      containing the declarations for the enabled/disable interrupts \n *      functions\n * EXTMODE_ENABLE_INTERRUPTS:  this defines the enable interrupts function\n * EXTMODE_DISABLE_INTERRUPTS: this defines the disable interrupts function\n *\n * If you define EXTMODE_PROTECT_CRITICAL_REGIONS, you need to define the \n * other above preprocessor defines, otherwise they are not required.\n */\n#ifdef EXTMODE_PROTECT_CRITICAL_REGIONS\n    #if !defined (EXTMODE_INTERRUPT_INC_HDR) || \\\n        !defined (EXTMODE_ENABLE_INTERRUPTS) || \\\n        !defined (EXTMODE_DISABLE_INTERRUPTS)\n        #error EXTMODE_INTERRUPT_INC_HDR, EXTMODE_ENABLE_INTERRUPTS and \\\n               EXTMODE_DISABLE_INTERRUPTS should be defined\n    #endif\n    /* \n     * include header file containing declarations for interrupt \n     * enable/disable functions \n     */    \n    #include EXTMODE_INTERRUPT_INC_HDR\n#endif\n\n/**********************\n * External Variables *\n **********************/\n#ifdef VXWORKS\n# include <sockLib.h>\n# include <inetLib.h>\n# include <selectLib.h>\nextern SEM_ID uploadSem;\n\n#endif\n\n/* Logical definitions */\n#if (!defined(__cplusplus))\n#  ifndef false\n#   define false                       (0U)\n#  endif\n#  ifndef true\n#   define true                        (1U)\n#  endif\n#endif\n\nboolean_T host_upstatus_is_uploading = false;\n\n/******************************************************************************\n * Parameter Download                                                         *\n ******************************************************************************/\n\n#ifdef VERBOSE\n/* Function: DType2Real_T ======================================================\n * Convert a built-in data type to a real_T value.  Return the real_T value\n * as well as a string (by reference) corresponding to the original data type.\n * If the data type is not recognized as a Simulink built-in data type, then\n * NULL is returned for the dTypeName and 0 is returned for the dTypeValue.\n */\nPRIVATE double DType2Double(\n    const char              *vPtr,\n    const int               dTypeIdx,\n    const DataTypeTransInfo *dtInfo,\n    const char              **dTypeName)\n{\n    real_T     outVal;\n    char * const *dTypeNames = (char * const *)dtGetDataTypeNames(dtInfo);\n    const char *thisName     = dTypeNames[dTypeIdx];\n\n    *dTypeName = thisName;\n\n    if (strcmp(thisName, \"real_T\") == 0) {\n        outVal = (real_T) (((const real_T*)vPtr)[0]);\n    } else if (strcmp(thisName, \"real32_T\") == 0) {\n        outVal = (real_T) (((const real32_T*)vPtr)[0]);\n    } else if (strcmp(thisName, \"int8_T\") == 0) {\n        outVal = (real_T) (((const int8_T*)vPtr)[0]);\n    } else if (strcmp(thisName, \"uint8_T\") == 0) {\n        outVal = (real_T) (((const uint8_T*)vPtr)[0]);\n    } else if (strcmp(thisName, \"int16_T\") == 0) {\n        outVal = (real_T) (((const int16_T*)vPtr)[0]);\n    } else if (strcmp(thisName, \"uint16_T\") == 0) {\n        outVal = (real_T) (((const uint16_T*)vPtr)[0]);\n    } else if (strcmp(thisName, \"int32_T\") == 0) {\n        outVal = (real_T) (((const int32_T*)vPtr)[0]);\n    } else if (strcmp(thisName, \"uint32_T\") == 0) {\n        outVal = (real_T) (((const uint32_T*)vPtr)[0]);\n    } else if (strcmp(thisName, \"boolean_T\") == 0) {\n        outVal = (real_T) (((const boolean_T*)vPtr)[0]);\n    } else {\n        outVal    = 0;\n        dTypeName = NULL;\n    }\n    return(outVal);\n} /* end DType2Double */\n#endif\n\n\n/* Function: SetParam ==========================================================\n * Install new parameters.\n *\n * NOTE: pbuf looks like:\n *  [NPARAMS\n *   B S W DI DATA   % pVal 0\n *   B S W DI DATA   % pVal 1\n *   B S W DI DATA   % pVal N\n *  ]\n *\n *  No assumptions about the alignment of pbuf may be made.\n *\n *  where,\n *      B   : Data type transition index.  Note that on the target the data\n *            type transition index provides both the base address (B)\n *              of the transition as well as whether or not\n *              that section of the array contains complex elements.\n *      S   : starting offset of the data from the DT_TRANS_IDX\n *      W   : number of elements for this param\n *      DI  : index into rtw data type table (inUse idx)\n *      DATA: the param values (in target format).\n *\n *  and,\n *      All values, excluding DATA, are int32_T.\n */\n#ifndef EXTMODE_DISABLEPARAMETERTUNING\nPUBLIC void SetParam(RTWExtModeInfo  *ei, const char *pbuf)\n{\n    int        i;\n    int32_T    nParams;\n    const char *bufPtr    = pbuf;\n    const int  B          = 0; /* index into dtype tran table (base address)  */\n    const int  SI         = 1; /* starting index - wrt to base address        */\n    const int  W          = 2; /* width of section (number of elements)       */\n    const int  DI         = 3; /* index into data type tables                 */\n    const int  tmpBufSize = sizeof(int32_T) * 4;\n    int32_T    tmpBuf[4];\n\n    const DataTypeTransInfo *dtInfo = (const DataTypeTransInfo *) rteiGetModelMappingInfo(ei);\n    const DataTypeTransitionTable *dtTable = dtGetParamDataTypeTrans(dtInfo);\n    const uint_T *dtSizes = dtGetDataTypeSizes(dtInfo);\n    \n#ifdef MW_DYNAMIC_STRING_SUPPORT\n    const char_T* *dtNames = dtGetDataTypeNames(dtInfo);\n#endif\n\n    /* unpack NPARAMS */\n    (void)memcpy(&nParams, bufPtr, sizeof(int32_T));\n    bufPtr += sizeof(int32_T);\n    \n#ifdef VERBOSE\n    printf(\"\\nUpdating %d parameters....\\n\", nParams);\n#endif\n\n    /*\n     * Unpack the data and install the new parameters.\n     */\n    for (i=0; i<nParams; i++) {\n        int_T   elSize;\n        int_T   nBytes;\n        char_T  *start;\n        char_T  *tranAddress;\n        int_T   tranIsComplex;\n\n        /* unpack B SI W DI */\n        (void)memcpy(tmpBuf, bufPtr, tmpBufSize);\n        bufPtr += tmpBufSize;\n\n        /* \n         * Find starting address and size (nBytes) for this parameters \n         * section of memory.\n         */\n        tranAddress   = dtTransGetAddress(dtTable, tmpBuf[B]);\n        tranIsComplex = dtTransGetComplexFlag(dtTable, tmpBuf[B]);\n\n        elSize = dtSizes[tmpBuf[DI]] * (tranIsComplex ? 2 : 1);\n        nBytes = tmpBuf[W] * elSize;\n\n        /*\n         * String in rapid accelerator is:\n         *   - transferred as character stream, element size is sizeof(char_T)\n         *   - stored/operated as void *, element size is sizeof(void*)\n         * We need to use the later one to calculate \"start\" address\n         */\n#ifdef MW_DYNAMIC_STRING_SUPPORT\n        if (strcmp(dtNames[tmpBuf[DI]], \"string\") == 0) {\n            elSize = sizeof(void*);\n        }\n#endif\n        start = tranAddress + (tmpBuf[SI] * elSize);\n\n        /* Install the params. */\n#ifdef MW_DYNAMIC_STRING_SUPPORT\n        if (strcmp(dtNames[tmpBuf[DI]], \"string\") == 0) {\n            suInitializeString(start, bufPtr);\n            bufPtr += nBytes;\n        } else\n#endif\n        {\n            (void)memcpy(start, bufPtr, nBytes);\n            bufPtr += nBytes;\n        }\n\n#ifdef VERBOSE\n        /*\n         * It is safe to assume that once the params are installed into\n         * the param vector that they are properly aligned.  So we\n         * do our verbosity print-out here.\n         */\n        {\n            double     val;\n            const char *dTypeName;\n            const char *vPtr = (const char *)start;\n\n            val = DType2Double(start, tmpBuf[DI], dtInfo, &dTypeName);\n            printf(\"\\n\\tParam| \"\n                   \"DT_Trans: %d, index: %d, nEls: %d, data type: [%s, %d]\\n\",\n                   tmpBuf[B], tmpBuf[SI], tmpBuf[W],\n                   (dTypeName != NULL) ? dTypeName : \"\",tmpBuf[DI]);\n\n            if (!tranIsComplex) {\n                int j;\n                for (j=0; j<tmpBuf[W]; j++) {\n                    val = DType2Double(vPtr, tmpBuf[DI], dtInfo, &dTypeName);\n                    printf(\"\\t\\t%f\\n\", val);\n                    vPtr += dtSizes[tmpBuf[DI]];\n                }\n            } else {\n                int j;\n                for (j=0; j<tmpBuf[W]; j++) {\n                    val = DType2Double(vPtr, tmpBuf[DI], dtInfo, &dTypeName);\n                    printf(\"\\t\\t%f + \", val);\n                    vPtr += dtSizes[tmpBuf[DI]];\n\n                    val = DType2Double(vPtr, tmpBuf[DI], dtInfo, &dTypeName);\n                    printf(\"\\t\\t%fi\\n\", val);\n                    vPtr += dtSizes[tmpBuf[DI]];\n                }\n            }\n        }\n#endif\n    }\n} /* end SetParam */\n#endif /* ifndef EXTMODE_DISABLEPARAMETERTUNING */\n\n\n/******************************************************************************\n * Parameter Upload                                                           *\n ******************************************************************************/\n#include \"upsup_public.h\"\n#define DUMP_PKT (0)\n\n\n/*=============================================================================\n * Circular buffer stuff.\n *============================================================================*/\ntypedef struct BufMemList_tag {\n\n#if ASSERTS_ON\n    int_T  maxBufs;     /* for debugging                       */\n#endif\n    int_T  nActiveBufs; /* num non-empty bufs                  */\n    int_T  *tids;       /* tid associated with each active buf */\n    BufMem *bufs;       /* sections of each buffer to upload   */\n} BufMemList;\n\n\ntypedef struct CircularBuf_tag {\n    volatile int_T    empty;\n\n    int_T    bufSize;\n    char_T   *buf;\n    \n    char_T* volatile head;\n    char_T* volatile tail;\n\n    char_T   *newTail;\n\n    struct {\n        int_T count;\n    } preTrig;\n} CircularBuf;\n\n\n/*==============================================================================\n * Trigger stuff.\n *============================================================================*/\ntypedef enum {\n    TRIGGER_UNARMED,\n    TRIGGER_HOLDING_OFF,\n    TRIGGER_ARMED,\n    TRIGGER_DELAYED,\n    TRIGGER_FIRED,\n    TRIGGER_TERMINATING\n} TriggerState;\n\n\n/*==============================================================================\n * General stuff.\n *============================================================================*/\n\n/*\n * An UploadSection defines a contiguous section of the blockio or dwork\n * structure.  Each section consists of elements of the same data type and same\n * complexity.\n * 'start' should be a const pointer\n */\ntypedef struct UploadSection_tag {\n    void   *start;\n    int_T  nBytes;\n#ifdef MW_DYNAMIC_STRING_SUPPORT\n    boolean_T isString;\n#endif\n} UploadSection;\n\n/*\n * An UploadMap is an array of UploadSections.  Typically a map consists of all\n * of the sections of the blockio or dwork structure that are relevant to a\n * given task.\n */\ntypedef struct UploadMap_tag {\n    int32_T    nSections;\n    UploadSection *sections;\n\n    int_T nBytes;  /* total number of bytes in this map */\n} UploadMap;\n\n\n/*\n * Each system contains a table of UploadMap's (one for each tid).  If no data\n * uploading is being done for a given tid, the uploadMap pointer is NULL.\n * The enableState field indicates whether the system in question is active.\n *\n * For a model with 5 total tids, the table looks like:\n *\n *               tid 0    tid 1    tid 2   tid 3   tid 4\n * uploadMap   -------------------------------------------\n *             |  ptr  |  NULL  |  NULL  |  ptr  |  NULL |\n *             ----|-------------------------|------------\n *                 |                         |\n *                 v                         v\n *              UploadMap                 UploadMap\n *              for tid 0                 for tid 3\n */\ntypedef struct SysUploadTable_tag {\n    int8_T    *enableState;\n    UploadMap **uploadMap;\n} SysUploadTable;\n\n\ntypedef struct TriggerInfo_tag {\n    TriggerState            state;\n    int_T                   tid;\n    int32_T                 duration;\n    int32_T                 holdOff;\n    int32_T                 delay;\n    int_T                   lookForRising;\n    int_T                   lookForFalling;\n    real_T                  level;\n    int_T                   count;\n    int_T                   overFlow;\n\n    UploadMap               trigSignals;\n    real_T                  *oldTrigSigVals;\n    int_T                   haveOldTrigSigVal;\n\n    struct {\n        int32_T    duration;\n        int32_T    count;\n\n        int_T      checkUnderFlow; /* ??? */\n    } preTrig;\n} TriggerInfo;\n\n\n/*\n * The BdUploadInfo contains all information regarding data logging.\n */\nstruct BdUploadInfo_tag {\n    int32_T        upInfoIdx;  /* index of upInfo in the array                 */\n    int32_T        nSys;       /* # of sys's for which data logging is active  */\n    SysUploadTable *sysTables; /* array of SysUploadTables                     */\n    CircularBuf    *circBufs;  /* circular buffers to store upload data        */\n    BufMemList     bufMemList; /* list of buffer memory holding data to upload */\n\n    TriggerInfo  trigInfo;\n};\n\n\n/*==============================================================================\n * Global upload data.\n */\n\n/*\n * Definitions that must match Simulink definitions.\n */\n\n#define UPLOAD_RISING_TRIGGER                   ((int32_T)  0)\n#define UPLOAD_FALLING_TRIGGER                  ((int32_T)  1)\n#define UPLOAD_EITHER_RISING_OR_FALLING_TRIGGER ((int32_T)  2)\n\n/*\n * Definitions.\n */\n#define TRIGMODE_ONESHOT (-1)\n\n#define NUM_UPINFOS   2\nstatic  BdUploadInfo  uploadInfoArray[NUM_UPINFOS];\n\n\n/* Function ====================================================================\n * Dump the signal selection packet (EXT_SELECT_SIGNALS).  The packet looks\n * like:\n *\n * upInfoIdx - Index of the UploadInfo. \n *\n * nSys - the number of systems that contain upload blocks (length of the\n *        (BdUploadInfo list)\n *\n * enableIdx - the index into the \"mode vector\" that tells whether or not\n *             a given system is active\n *\n * nTids - the number of tids in a system that contain upload blocks (number\n *         of non NULL entries in a SysUploadTable)\n *\n * nSections - the number of contiguous blockio or dwork sections that\n *             correspond to all blocks within a tid (number of sections in\n *             an UploadMap)\n *\n * B  - Index into data type transition table       - gives base address\n * S  - the starting index of a blockio section     - with respect to B\n * W  - the number of elements in a blockio section\n * DI - data type index - index into the rtw data type table\n *\n * target buf size - size of the upload buffer (to be allocated by target) for\n *                   a given tid\n *\n * Here's the packet format:\n *\n * [upInfoIdx\n *  \n *  nSys\n *\n *  enableIdx                           ---\n *  nTids                                 |\n *  tid nSections B S W DI B S W DI ...   | system\n *  tid nSections B S W DI B S W DI ...   |\n *                                      ---\n *  enableIdx                           ---\n *  nTids                                 |\n *  tid nSections B S W DI B S W DI ...   | system\n *  tid nSections B S W DI B S W DI ...   |\n *                                      ---\n *  target buf size for tid 0\n *  target buf size for tid 1\n *            .\n *            .\n *  target buf size for tid n\n * ]\n *\n * All elements are int32_T.\n */\n#if DUMP_PKT\nPRIVATE void DumpSelectSignalPkt(const char *pkt, int nRootTids)\n{\n    int32_T    i,j,k;\n    int32_T    upInfoIdx;\n    int32_T    nSys;\n    const char *bufPtr = pkt;\n\n    printf(\"Signal Select Pkt-----------\\n\");\n\n    /* upInfoIdx */\n    (void)memcpy(&upInfoIdx, bufPtr, sizeof(int32_T));\n    bufPtr += sizeof(int32_T);\n\n    printf(\"\\nupInfoIdx: %d\\n\",upInfoIdx);\n\n    /* nSys */\n    (void)memcpy(&nSys, bufPtr, sizeof(int32_T));\n    bufPtr += sizeof(int32_T);\n\n    printf(\"\\nnSys: %d\\n\",nSys);\n\n    for (i=0; i<nSys; i++) {\n        int32_T enableIdx, nTids;\n        \n        /* [enableIdx, nTids] */\n        (void)memcpy(&enableIdx, bufPtr, sizeof(int32_T));\n        bufPtr += sizeof(int32_T);\n\n        (void)memcpy(&nTids, bufPtr, sizeof(int32_T));\n        bufPtr += sizeof(int32_T);\n\n        printf(\"[enableIdx, nTids]: %d %d\\n\", enableIdx, nTids);\n\n        for (j=0; j<nTids; j++) {\n            int32_T tid;\n            int32_T nSections;\n\n            /* [tid nSections] */\n            (void)memcpy(&tid, bufPtr, sizeof(int32_T));\n            bufPtr += sizeof(int32_T);\n\n            (void)memcpy(&nSections, bufPtr, sizeof(int32_T));\n            bufPtr += sizeof(int32_T);\n\n            printf(\"[tid nSects]: %d %d\\n\", tid, nSections);\n\n            for (k=0; k<nSections; k++) {\n                const int B  = 0;\n                const int S  = 1;\n                const int W  = 2;\n                const int DI = 3;\n                int32_T   tmpBuf[4];\n\n                /* [B S W DI] */\n                (void)memcpy(&tmpBuf, bufPtr, sizeof(int32_T)*4);\n                bufPtr += (sizeof(int32_T) * 4);\n                \n                printf(\"%d %d %d %d\\n\",\n                    tmpBuf[B], tmpBuf[S], tmpBuf[W], tmpBuf[DI]);\n            }\n            printf(\"\\n\");\n        }\n        printf(\"\\n\");\n    }\n\n    /*\n     * Now the buffer sizes.\n     */\n    printf(\"bufSizes: \");\n    for (i=0; i<nRootTids; i++) {\n        int32_T bufSize;\n\n        printf(\"\\nbufSize[%d] of %d: \",i, nRootTids);\n\n        (void)memcpy(&bufSize, bufPtr, sizeof(int32_T));\n        bufPtr += sizeof(int32_T);\n\n        printf(\"%d\", bufSize);\n    }\n    printf(\"\\nEnd of select sigs pkt----\\n\");\n} /* end DumpSelectSignalPkt */\n#else\n#define DumpSelectSignalPkt(buf, nRootTids) /* do nothing */\n#endif\n\n\n/* Function ====================================================================\n * Dump the trigger selection packet (EXT_SELECT_TRIGGER).  The packet looks\n * like:\n *\n * upInfoIdx - Index of the UploadInfo. \n *\n * tid       - tid of the trigger signal\n *\n * duration  - The number of base rate steps for which the data logging event\n *             occurs.\n *\n * holdOff   - (-1), signifies that this trigger event is a one_shot, else we \n *             are in normal mode.  For normal mode the value indicates\n *             the number of base rate steps to wait between the end a data\n *             logging event and the re-arming of the trigger for the next data\n *             logging event.  The end of a data logging event is defined as\n *             when the last bit of data has been sent to the host (i.e.,\n *             immediately after the termination flag has been sent).\n *\n * delay     - The number of base rate steps to wait after the trigger event\n *             occurs and the before starting the data collection.  This can\n *             be either positive or negative (pre-trigger).  This field is\n *             ignored if the trigger source is manual.\n *\n * nsections - The sections of the blockio array to monitor for a trigger event.\n *             If the trigger event is not based on a signal, this is set to\n *             0 (e.g., the signal source is manual).\n *\n * sections  - \"B, S, W, DI\" description of a signal (see Signal Selection Pkt).\n *             These are the elements of the blockio vector that are monitored\n *             for trigger events when the trigger is based on a signal.  It is\n *             ignored if the trigger event is not based on a signal\n *             (nsections == 0).\n *\n * direction - If the triggering source is a signal, then this specifies the\n *             direction of the crossing (rising, falling or either).  If we\n *             are not triggering on a signal (nsections == 0), then this field\n *             is ignored.\n *\n * level     - If the triggering source is a signal, then this field specifies\n *             the level (value) of the crossing (0 by default).  If we are not\n *             triggering on a signal (nsections == 0), then this field is\n *             ignored.\n *\n * The packet looks like:\n * [tid duration holdOff delay nsections B S W DI B S W DI ... direction level]\n *\n * All fields are int32_T except for level, which is an SL_DOUBLE (real_T\n * on target).\n */\n#if DUMP_PKT\nPRIVATE void DumpSelectTriggerPkt(const char *pkt)\n{\n    int32_T    i;\n    int32_T    upInfoIdx, tid, duration, holdOff, delay, nSections;\n    int32_T    direction;\n    real_T     level;\n    const char *bufPtr = pkt;\n\n    printf(\"Trigger Select Pkt-----------\\n\");\n\n    /* upInfoIdx */\n    (void)memcpy(&upInfoIdx, bufPtr, sizeof(int32_T));\n    bufPtr += sizeof(int32_T);\n\n    printf(\"\\nupInfoIdx: %d\\n\",upInfoIdx);\n    \n    /* tid */\n    (void)memcpy(&tid, bufPtr, sizeof(int32_T));\n    bufPtr += sizeof(int32_T);\n\n    printf(\"\\ntid: %d\\n\",tid);\n    \n    /* duration */\n    (void)memcpy(&duration, bufPtr, sizeof(int32_T));\n    bufPtr += sizeof(int32_T);\n\n    printf(\"\\nduration: %d\\n\",duration);\n\n    /* holdOff */\n    (void)memcpy(&holdOff, bufPtr, sizeof(int32_T));\n    bufPtr += sizeof(int32_T);\n\n    printf(\"\\nholdOff: %d\\n\",holdOff);\n\n    /* delay */\n    (void)memcpy(&delay, bufPtr, sizeof(int32_T));\n    bufPtr += sizeof(int32_T);\n\n    printf(\"\\ndelay: %d\\n\",delay);\n\n    /* nsections */\n    (void)memcpy(&nSections, bufPtr, sizeof(int32_T));\n    bufPtr += sizeof(int32_T);\n\n    printf(\"nSects: %d\\n\", nSections);\n\n    /* each section */\n    for (i=0; i<nSections; i++) {\n        const int B  = 0;\n        const int S  = 1;\n        const int W  = 2;\n        const int DI = 3;\n        int32_T   tmpBuf[4];\n\n        (void)memcpy(&tmpBuf, bufPtr, sizeof(int32_T)*4);\n        bufPtr += (sizeof(int32_T) * 4);\n        \n        printf(\"%d %d %d %d\\n\", tmpBuf[B], tmpBuf[S], tmpBuf[W], tmpBuf[DI]);\n    }\n    printf(\"\\n\");\n\n    /* direction */\n    (void)memcpy(&direction, bufPtr, sizeof(int32_T));\n    bufPtr += sizeof(int32_T);\n\n    printf(\"direction: %d\\n\",direction);\n\n    /* level */\n    (void)memcpy(&level, bufPtr, sizeof(real_T));\n    bufPtr += sizeof(real_T);\n\n    printf(\"level: %f\\n\",level);\n} /* end DumpSelectTriggerPkt */\n#else\n#define DumpSelectTriggerPkt(buf) /* do nothing */\n#endif\n\n\n/* Function ====================================================================\n * Initialize a UploadSection.\n */\n#ifndef EXTMODE_DISABLESIGNALMONITORING\nPRIVATE void InitUploadSection(\n    RTWExtModeInfo *ei,\n    const int32_T  *buf,\n    UploadSection  *section)   /* out */\n{\n    int_T                         elSize;\n    int_T                         offset;\n    int_T                         nBytes;\n    char_T                        *tranAddress;\n    int_T                         tranIsComplex;\n    \n    const DataTypeTransInfo       *dtInfo  = (const DataTypeTransInfo *) rteiGetModelMappingInfo(ei);\n    const DataTypeTransitionTable *dtTable = dtGetBIODataTypeTrans(dtInfo);\n    const uint_T *dtSizes = dtGetDataTypeSizes(dtInfo);\n\n    const int BI = 0;  /* index into dtype tran table (base address)  */\n    const int SI = 1;  /* starting index - wrt to base address        */\n    const int W  = 2;  /* width of section (number of elements)       */\n    const int DI = 3;  /* index into data type tables                 */\n\n#ifdef MW_DYNAMIC_STRING_SUPPORT\n    const char_T* *dtNames;\n#endif\n    \n    tranAddress   = dtTransGetAddress(dtTable, buf[BI]);\n    tranIsComplex = dtTransGetComplexFlag(dtTable, buf[BI]);\n\n    elSize = dtSizes[buf[DI]] * (tranIsComplex ? 2 : 1);\n    nBytes = buf[W] * elSize;\n    offset = buf[SI] * elSize;\n\n    section->start  = tranAddress + offset;\n    section->nBytes = nBytes;\n    \n#ifdef MW_DYNAMIC_STRING_SUPPORT\n    dtNames = dtGetDataTypeNames(dtInfo);\n    section->isString = strcmp(dtNames[buf[DI]], \"string\") == 0;\n#endif\n    \n} /* end InitUploadSection */\n\n\n/* Function ====================================================================\n * Initialize a SysUploadTable.  The callerBufPtr points to the current place in\n * the EXT_SELECT_SIGNALS pkt which should be the enableIdx field.  This\n * function moves the callerBufPtr to the next unread field of the packet.\n */\nPRIVATE boolean_T InitSysUploadTable(\n    RTWExtModeInfo *ei,\n    int_T          numSampTimes,\n    SysUploadTable *sysTable,\n    const char     **callerBufPtr) /* in/out */\n{\n    int_T        i;\n    int32_T      nTids;\n    const char_T *bufPtr = *callerBufPtr;\n    boolean_T    error   = EXT_NO_ERROR;\n\n    /*\n     * Set pointer to enable mode.\n     */\n    {\n        int32_T sysIdx;\n\n        /* read sysIdx */\n        (void)memcpy(&sysIdx, bufPtr, sizeof(int32_T));\n        bufPtr += sizeof(int32_T);\n\n        sysTable->enableState = rteiGetAddrOfSubSystemActiveVector(ei,sysIdx);\n    }\n\n    /*\n     * Allocate/initialize each tid's uploadMap.\n     */\n\n    /* ...read [nTids] */\n    (void)memcpy(&nTids, bufPtr, sizeof(int32_T));\n    bufPtr += sizeof(int32_T);\n\n    /* Allocate the array of pointers to UploadMaps. */\n    sysTable->uploadMap = (UploadMap **)calloc(numSampTimes, sizeof(UploadMap *));\n    if (sysTable->uploadMap == NULL) {\n        error = EXT_ERROR; goto EXIT_POINT;       \n    }\n\n    for (i=0; i<nTids; i++) {\n        int32_T   tid;\n        int32_T   section;\n        UploadMap *map;\n        \n        /* read tid */\n        (void)memcpy(&tid, bufPtr, sizeof(int32_T));\n        bufPtr += sizeof(int32_T);\n        \n        /* allocate UploadMap */\n        assert(sysTable->uploadMap[tid] == NULL);\n        sysTable->uploadMap[tid] = (UploadMap *)calloc(1, sizeof(UploadMap));\n        if (sysTable->uploadMap[tid] == NULL) {\n            error = EXT_ERROR; goto EXIT_POINT;       \n        }\n        map = sysTable->uploadMap[tid];\n        \n        /* read nSections */\n        (void)memcpy(&map->nSections, bufPtr, sizeof(int32_T));\n        bufPtr += sizeof(int32_T);\n\n        /* Allocate the blockio sections. */\n        assert(map->sections == NULL);\n        if (map->nSections > 0) {\n           map->sections = (UploadSection *)calloc(map->nSections,sizeof(UploadSection));\n           if (map->sections == NULL) {\n               error = EXT_ERROR; goto EXIT_POINT;\n           }\n        }\n\n        /*\n         * Init the UploadSections.\n         */\n        for (section=0; section<map->nSections; section++) {\n            int32_T    tmpBuf[4];\n            UploadSection *uploadSection = &map->sections[section];\n\n            /* read [B S W DI] */\n            (void)memcpy(&tmpBuf, bufPtr, sizeof(int32_T)*4);\n            bufPtr += (sizeof(int32_T) * 4);\n\n            InitUploadSection(ei, tmpBuf, uploadSection);\n\n            /* keep track of total number of bytes in this map */\n            map->nBytes += uploadSection->nBytes;\n        }\n    }\n    \nEXIT_POINT:\n    *callerBufPtr = bufPtr;\n    return(error);\n} /* end InitSysUploadTable */\n\n/* Function ====================================================================\n * Initialize circular buffer fields and allocate required memory.\n */\nPRIVATE boolean_T UploadBufInit(CircularBuf *circBuf, int32_T size)\n{\n    boolean_T error = NO_ERR;\n\n    assert(circBuf->buf == NULL);\n\n    /*\n     * Size will be negative to indicate an error if host determines too much\n     * memory is needed (i.e. the size will not fit in an int32).\n     */\n    if (size < 0) {\n        error = EXT_ERROR; goto EXIT_POINT;\n    }\n\n    circBuf->empty = true;\n    if (size > 0) {\n        assert(circBuf->buf == NULL);\n        circBuf->buf = (char_T *)malloc(size);\n        if (circBuf->buf == NULL) {\n            error = EXT_ERROR; goto EXIT_POINT;\n        }\n    } else {\n        circBuf->buf = NULL;\n    }\n    circBuf->bufSize = size;\n    \n    circBuf->head = circBuf->buf;\n    circBuf->tail = circBuf->buf;\n\n    circBuf->newTail = NULL;\n\nEXIT_POINT:\n    return(error);\n} /* end UploadBufInit */\n#endif /* ifndef EXTMODE_DISABLESIGNALMONITORING */\n\n\n/* Function ====================================================================\n * Free all dynamically allocated fields of the trigInfo structure.\n */\nPRIVATE void UploadDestroyTrigger(int32_T upInfoIdx)\n{\n    BdUploadInfo *uploadInfo = &uploadInfoArray[upInfoIdx];\n    TriggerInfo *trigInfo    = &uploadInfo->trigInfo;\n    UploadMap   *map         = &trigInfo->trigSignals;\n\n    if (map->sections != NULL) {\n        free(map->sections);\n        map->sections = NULL;\n    }\n\n    if (trigInfo->oldTrigSigVals != NULL) {\n        free(trigInfo->oldTrigSigVals);\n        trigInfo->oldTrigSigVals = NULL;\n    }\n\n    /*\n     * Reset trigger info.\n     */\n    trigInfo->state          = TRIGGER_UNARMED;\n    trigInfo->duration       = 0;\n    trigInfo->holdOff        = 0;\n    trigInfo->delay          = 0;\n    trigInfo->lookForRising  = true;\n    trigInfo->lookForFalling = false;\n    trigInfo->level          = (real_T)0;\n    trigInfo->count          = 0;\n    trigInfo->overFlow       = false;\n\n    trigInfo->trigSignals.nSections = 0;\n    trigInfo->trigSignals.sections  = NULL;\n    trigInfo->trigSignals.nBytes    = 0;\n\n    trigInfo->oldTrigSigVals    = NULL;\n    trigInfo->haveOldTrigSigVal = false;\n\n    trigInfo->preTrig.duration       = 0;\n    trigInfo->preTrig.count          = 0;\n    trigInfo->preTrig.checkUnderFlow = false;\n} /* end UploadDestroyTrigger */\n\n\n/* Function ====================================================================\n * Reset fields of the uploadinfo struct.\n */\nPUBLIC void UploadLogInfoReset(int32_T upInfoIdx)\n{\n    static boolean_T firstTime[NUM_UPINFOS] = {true, true};\n    BdUploadInfo     *uploadInfo = &uploadInfoArray[upInfoIdx];\n    \n    /*\n     * uploadInfoArray is declared as global static, so most compilers will\n     * initialize the memory to zero.  However, the tic6000 assigns this\n     * variable into uninitialized memory.  When this function is called for\n     * the first time, we attempt to free garbage pointers and crash.  By\n     * clearing unloadInfoArray explicitly the first time this function is\n     * called, we can ensure that this function will work for all compilers.\n     */\n    if (firstTime[upInfoIdx]) {\n        memset(uploadInfo, 0, sizeof(BdUploadInfo));\n        firstTime[upInfoIdx] = false;\n    }\n   \n    /* sysUploadTable */\n    uploadInfo->nSys      = 0;\n    uploadInfo->sysTables = NULL;\n\n    uploadInfo->circBufs = NULL;\n\n    uploadInfo->bufMemList.bufs = NULL;\n    uploadInfo->bufMemList.tids = NULL;\n\n    /* Reset trigger info */\n    UploadDestroyTrigger(upInfoIdx);\n\n} /* end UploadLogInfoReset */\n\n\n/* Function ====================================================================\n * Destroy all data associated with data logging.  Fields are re-initialized\n * and pointers NULL'ed out by UploadLogInfoReset().\n */\nPUBLIC void UploadLogInfoTerm(int32_T upInfoIdx, int_T numSampTimes)\n{\n    int_T i;\n    BdUploadInfo *uploadInfo = &uploadInfoArray[upInfoIdx];\n\n    if (uploadInfo->nSys == 0) return; /* Nothing to terminate */\n\n    /*\n     * Free fields of the sysUpload tables and then the table itself.\n     */\n    for (i=0; i<uploadInfo->nSys; i++) {\n        int_T     tid;\n        UploadMap **uploadMap = uploadInfo->sysTables[i].uploadMap;\n        \n        for (tid=0; tid<numSampTimes; tid++) {\n            if (uploadMap[tid] != NULL) {\n                /* Free fields of uploadMap. */\n                free(uploadMap[tid]->sections);\n\n                /* Free the uploadMap. */\n                free(uploadMap[tid]);\n            }\n        }\n\n        free(uploadMap);\n    }\n\n    free(uploadInfo->sysTables);\n\n    /* Free circular buf fields and bufMemLists. */\n    if (uploadInfo->circBufs) {\n        for (i=0; i<numSampTimes; i++) {\n            free(uploadInfo->circBufs[i].buf);\n        }\n        free(uploadInfo->circBufs);\n    }\n\n    free(uploadInfo->bufMemList.bufs);\n    free(uploadInfo->bufMemList.tids);\n    \n    /*\n     * Free trigger info.\n     */\n    UploadDestroyTrigger(upInfoIdx);\n\n    /*\n     * Reset all vals to initial value and NULL out pointers.\n     */\n    UploadLogInfoReset(upInfoIdx);\n} /* end UploadLogInfoTerm */\n\n\n/* Function ====================================================================\n * Prepare for final flush of buffers.  This involves setting the trigger\n * state to appropriate values.\n */\nPUBLIC void UploadPrepareForFinalFlush(int32_T upInfoIdx)\n{\n    BdUploadInfo *uploadInfo = &uploadInfoArray[upInfoIdx];\n\n    switch(uploadInfo->trigInfo.state) {\n    case TRIGGER_FIRED:\n    case TRIGGER_TERMINATING:\n        /*\n         * 1) set trig state to \"terminating\" so that the eventual call to\n         *    UploadBufGetData knows to add the terminator flag to\n         *    the data stream.\n         * 2) set trig state to \"oneshot\" to prevent re-arming\n         */\n        uploadInfo->trigInfo.state   = TRIGGER_TERMINATING; /* 1 */\n        uploadInfo->trigInfo.holdOff = TRIGMODE_ONESHOT;    /* 2 */\n        break;\n\n    case TRIGGER_UNARMED:\n    case TRIGGER_HOLDING_OFF:\n    case TRIGGER_ARMED:\n    case TRIGGER_DELAYED:\n        /* do nothing */\n        break;\n    }\n\n#ifdef VXWORKS\n    /* Let upload server run to ensure that term pkt is sent to host. One\n       semGive() is for the background task and the other is for the explicit\n       call to rt_UploadServerWork() in DisconnectFromHost(). */\n    semGive(uploadSem);\n    semGive(uploadSem);\n#endif\n\t\n} /* end UploadPrepareForFinalFlush */\n\n\n/* Function ====================================================================\n * Initialize data uploading by processing the EXT_SELECT_SIGNALS packet\n * (which is passed in).  Return the error status.  See DumpSelectSignalPkt()\n * for a detailed description of the packet.\n */\n#ifndef EXTMODE_DISABLESIGNALMONITORING\nPUBLIC boolean_T UploadLogInfoInit(RTWExtModeInfo *ei,\n                                   int_T          numSampTimes,\n                                   const char     *pkt,\n                                   int32_T        upInfoIdx)\n{\n    int          nActiveTids;\n    int_T        i;\n    boolean_T    error   = EXT_NO_ERROR;\n    const char   *bufPtr = pkt;\n    BdUploadInfo *uploadInfo;\n\n    DumpSelectSignalPkt(pkt, numSampTimes);\n\n    /* Point to the correct uploadInfo */\n    uploadInfo           = &uploadInfoArray[upInfoIdx];\n    uploadInfo->upInfoIdx = upInfoIdx;\n\n    /* Free upInfo if fields are already allocated */\n    UploadLogInfoTerm(upInfoIdx, numSampTimes);\n\n    /* nSys */\n    (void)memcpy(&uploadInfo->nSys, bufPtr, sizeof(int32_T));\n    bufPtr += sizeof(int32_T);\n    assert(uploadInfo->sysTables == NULL);\n    uploadInfo->sysTables = (SysUploadTable *)\n        calloc(uploadInfo->nSys, sizeof(SysUploadTable));\n    if (uploadInfo->sysTables == NULL) {\n        error = EXT_ERROR; goto EXIT_POINT;\n    }\n\n    /*\n     * Init each system table.\n     */\n    for (i=0; i<uploadInfo->nSys; i++) {\n        error = InitSysUploadTable(ei, numSampTimes,\n                                   &uploadInfo->sysTables[i], &bufPtr);\n        if (error != EXT_NO_ERROR) goto EXIT_POINT;\n    }\n\n    assert(uploadInfo->circBufs == NULL);\n    uploadInfo->circBufs = (CircularBuf *) calloc(numSampTimes,\n                                                  sizeof(CircularBuf));\n\n    /*\n     * Allocate the circular buffers.\n     */\n    nActiveTids = 0;\n    for (i=0; i<numSampTimes; i++) {\n        int32_T size;\n        \n        (void)memcpy(&size, bufPtr, sizeof(int32_T));\n        bufPtr += sizeof(int32_T);\n        \n        error = UploadBufInit(&uploadInfo->circBufs[i], size);\n        if (error != EXT_NO_ERROR) goto EXIT_POINT;\n\n        nActiveTids += (size != 0);\n    }\n\n    /*\n     * Initialize/Allocate the bufMemLists - these are used by\n     * ext_svr to pull the appropriate data out of the buffers and send it\n     * to the host.\n     */\n#if ASSERTS_ON\n    uploadInfo->bufMemList.maxBufs = nActiveTids;\n#endif\n    uploadInfo->bufMemList.nActiveBufs = 0;\n\n    assert(uploadInfo->bufMemList.bufs == NULL);\n    uploadInfo->bufMemList.bufs = (BufMem *)malloc(nActiveTids*sizeof(BufMem));\n    if (uploadInfo->bufMemList.bufs == NULL) {\n        error = EXT_ERROR; goto EXIT_POINT;\n    }\n\n    assert(uploadInfo->bufMemList.tids == NULL);\n    uploadInfo->bufMemList.tids = (int_T *)malloc(nActiveTids*sizeof(int_T));\n    if (uploadInfo->bufMemList.tids == NULL) {\n        error = EXT_ERROR; goto EXIT_POINT;\n    }\n\nEXIT_POINT:\n    if (error != EXT_NO_ERROR) {\n        UploadLogInfoTerm(upInfoIdx, numSampTimes);\n    }\n    return(error);\n} /* end UploadLogInfoInit */\n\n\n/* Function ====================================================================\n * Initialize and configure the trigger attributes.  See DumpSelectTriggerPkt()\n * for a detailed description of the packet.\n */\nPUBLIC boolean_T UploadInitTrigger(RTWExtModeInfo *ei,\n                                   const char     *pkt,\n                                   int32_T         upInfoIdx)\n{\n    int_T       nSections;\n    int32_T     i32_tid;\n    int32_T     direction;\n    TriggerInfo *trigInfo;\n    boolean_T   error     = EXT_NO_ERROR;\n    const char  *bufPtr   = pkt;\n    \n    DumpSelectTriggerPkt(pkt);\n    \n    /* Select the trig Info */\n    trigInfo = &uploadInfoArray[upInfoIdx].trigInfo;\n\n    /* tid, duration, holdOff, delay and nsections */\n    (void)memcpy(&i32_tid, bufPtr, sizeof(int32_T));\n    bufPtr += sizeof(int32_T);\n    trigInfo->tid = (int_T)i32_tid;\n\n    (void)memcpy(&trigInfo->duration, bufPtr, sizeof(int32_T));\n    bufPtr += sizeof(int32_T);\n\n    (void)memcpy(&trigInfo->holdOff, bufPtr, sizeof(int32_T));\n    bufPtr += sizeof(int32_T);\n\n    (void)memcpy(&trigInfo->delay, bufPtr, sizeof(int32_T));\n    bufPtr += sizeof(int32_T);\n\n    (void)memcpy(&trigInfo->trigSignals.nSections, bufPtr, sizeof(int32_T));\n    bufPtr += sizeof(int32_T);\n    \n    nSections = trigInfo->trigSignals.nSections;\n\n    /*\n     * Init the UploadSections - if the trigger is signal based.\n     */\n    if (nSections > 0) {\n        /* trigger is signal based */\n        int       section;\n        UploadMap *map = &trigInfo->trigSignals;\n\n        assert(map->nBytes == 0);\n        assert(map->sections == NULL);\n        map->sections = (UploadSection *)malloc(nSections * sizeof(UploadSection));\n        if (map->sections == NULL) {\n            error = EXT_ERROR; goto EXIT_POINT;\n        }\n            \n        for (section=0; section<map->nSections; section++) {\n            int32_T       tmpBuf[4];\n            UploadSection *uploadSection = &map->sections[section];\n\n            /* read [B S W DI] */\n            (void)memcpy(&tmpBuf, bufPtr, sizeof(int32_T)*4);\n            bufPtr += (sizeof(int32_T) * 4);\n            \n            InitUploadSection(ei, tmpBuf, uploadSection);\n\n            /* keep track of total number of bytes in this map */\n            map->nBytes += uploadSection->nBytes;\n        }\n\n        /*\n         * Allocate space to hold the old values of the trigger signals.  Note\n         * that trigger signals are guaranteed to be of type SL_DOUBLE (real_T)\n         * and non-complex.\n         */\n        assert(trigInfo->oldTrigSigVals == NULL);\n        assert(trigInfo->oldTrigSigVals == NULL);\n        trigInfo->oldTrigSigVals = (real_T *)malloc(map->nBytes);\n        if (trigInfo->oldTrigSigVals == NULL) {\n            error = EXT_ERROR; goto EXIT_POINT;\n        }\n    }\n            \n    /* Direction. */\n    (void)memcpy(&direction, bufPtr, sizeof(int32_T));\n    bufPtr += sizeof(int32_T);\n\n    trigInfo->lookForRising  = \n        ((direction == UPLOAD_RISING_TRIGGER)  || \n         (direction == UPLOAD_EITHER_RISING_OR_FALLING_TRIGGER));\n\n    trigInfo->lookForFalling = \n        ((direction == UPLOAD_FALLING_TRIGGER) || \n         (direction == UPLOAD_EITHER_RISING_OR_FALLING_TRIGGER));\n    \n    /* level */\n    (void)memcpy(&trigInfo->level, bufPtr, sizeof(real_T));\n    bufPtr += sizeof(real_T);\n\n    /*\n     * Convert delay to pre-trigger duration.\n     */\n    if (trigInfo->delay < 0) {\n        trigInfo->preTrig.duration = -trigInfo->delay;\n        trigInfo->delay            = 0;\n    } else {\n        trigInfo->preTrig.duration = 0;\n    }\n\nEXIT_POINT:\n    if (error != EXT_NO_ERROR) {\n        UploadDestroyTrigger(upInfoIdx);\n    }\n    return(error);\n} /* end UploadInitTrigger */\n\n\n/* Function ====================================================================\n * Arm the trigger.\n */\nPUBLIC void UploadArmTrigger(int32_T upInfoIdx, int_T numSampTimes)\n{\n    int_T   tid;\n    BdUploadInfo *uploadInfo = &uploadInfoArray[upInfoIdx];\n\n    assert((uploadInfo->trigInfo.state == TRIGGER_UNARMED) ||\n           (uploadInfo->trigInfo.state == TRIGGER_HOLDING_OFF));\n\n    host_upstatus_is_uploading = false;\n\n    /*\n     * Re-initialize.\n     */\n    uploadInfo->trigInfo.overFlow = false;\n    for (tid=0; tid<numSampTimes; tid++) {\n        CircularBuf *circBuf = &uploadInfo->circBufs[tid];\n        if (circBuf->bufSize > 0) {\n            circBuf->head = circBuf->buf;\n            circBuf->tail = circBuf->buf;\n\n            circBuf->newTail = NULL;\n            circBuf->empty   = true;\n        }\n    }\n\n    /* \n     * Re-initialize trigger fields.\n     */\n    uploadInfo->trigInfo.count             = 0;\n    uploadInfo->trigInfo.haveOldTrigSigVal = false;\n\n    /* \n     * Reset pre-trig counts for normal mode.\n     */\n    uploadInfo->trigInfo.preTrig.count = 0;\n\n    /* \n     * Re-arm after all initialization.  Make sure that trigInfo.state is\n     * set last since this routine may be interrupted.\n     */\n    uploadInfo->trigInfo.state = TRIGGER_ARMED;\n\n} /* end UploadArmTrigger */\n#endif /* ifndef EXTMODE_DISABLESIGNALMONITORING */\n\n/* Function ====================================================================\n * Terminate this data logging session by destroying the uploadInfo and\n * setting the trigger backed to the unarmed state.\n */\nPUBLIC void UploadEndLoggingSession(int32_T upInfoIdx, int_T numSampTimes)\n{\n    BdUploadInfo *uploadInfo = &uploadInfoArray[upInfoIdx];\n\n    uploadInfo->trigInfo.state = TRIGGER_UNARMED;\n    UploadLogInfoTerm(upInfoIdx, numSampTimes);\n} /* end UploadEndLoggingSession */\n\n\n/* Function ====================================================================\n * Cancel this data logging session.\n */\nPUBLIC void UploadCancelLogging(int32_T upInfoIdx)\n{\n    BdUploadInfo *uploadInfo = &uploadInfoArray[upInfoIdx];\n\n    switch(uploadInfo->trigInfo.state) {\n\n    case TRIGGER_UNARMED:\n        break;\n\n    case TRIGGER_HOLDING_OFF:\n    case TRIGGER_ARMED:\n    case TRIGGER_DELAYED:\n    case TRIGGER_FIRED:\n        /*\n         * Move to TRIGGER_TERMINATING and ensure that we are no longer in\n         * \"normal\" mode (TRIGMODE_NORMAL) so that the trigger does not get\n         * re-armed.\n         */\n        uploadInfo->trigInfo.holdOff = TRIGMODE_ONESHOT;\n        uploadInfo->trigInfo.state   = TRIGGER_TERMINATING;\n#ifdef VXWORKS\n        /*\n         * Let upload server run to ensure that term pkt is sent to host (needed\n         * for all but the TRIGGERED_FIRED case since the upload server is\n         * inactive).\n         */\n        semGive(uploadSem);\n#endif\n        break;\n    \n    case TRIGGER_TERMINATING:\n        /*\n         * Ensure that we are no longer in \"normal\" mode (TRIGMODE_NORMAL) so\n         * that the trigger does not get re-armed.\n         */\n        uploadInfo->trigInfo.holdOff = TRIGMODE_ONESHOT;\n        break;\n    }\n} /* end UploadCancelLogEvent */\n\n\n/* Function ====================================================================\n * Called by ext_svr (background task), in order to perform tasks that need\n * to be done after each time that data has been sent to the host.  This\n * includes:\n *\n * o move the tail for the specified buffer forward\n * o detect the end of a data logging event so that the trigger state can\n *   be either set to unarmed (for one shot) or backed to armed (for normal\n *   mode).\n * \n * NOTE:  UploadBufGetData and UploadBufMoveTail must be called in pairs where the\n *        UploadBufGetData call precedes the UploadBufMoveTail call.\n */\n#ifndef EXTMODE_DISABLESIGNALMONITORING\nPUBLIC void UploadBufDataSent(const int_T tid, int32_T upInfoIdx)\n{   \n    BdUploadInfo *uploadInfo = &uploadInfoArray[upInfoIdx];\n    CircularBuf  *circBuf    = &uploadInfo->circBufs[tid];            \n\n    host_upstatus_is_uploading = true;\n    \n    /* Move the tail forward. */\n    circBuf->tail = circBuf->newTail;\n        \n#ifdef EXTMODE_PROTECT_CRITICAL_REGIONS\n    /* \n     * disable interrupts around this critical region. We need to \n     * guarantee that reading the head pointer is an atomic \n     * operation.\n     */\n    EXTMODE_DISABLE_INTERRUPTS;\n#endif\n    \n    /* \n     * Since we are moving the tail forward, we know that head == tail\n     * represents an empty buffer and not a full buffer.\n     */\n    circBuf->empty = (circBuf->tail == circBuf->head);\n    \n#ifdef EXTMODE_PROTECT_CRITICAL_REGIONS\n    /* re-enable interrupts */\n    EXTMODE_ENABLE_INTERRUPTS;\n#endif\n\n} /* end UploadBufDataSent */\n#endif /* ifndef EXTMODE_DISABLESIGNALMONITORING */\n\n/*\n * Macro =======================================================================\n * Move the tail of a circular buffer forward by one time step - accounting for\n * wrapping.\n */\n#define MOVE_TAIL_ONESTEP(circBuf, end)                            \\\n{                                                                  \\\n    int     nBytesPassedEnd;                                       \\\n    int     nBytesInStep;                                          \\\n    int32_T *nBytesPtr = (int32_T *)((circBuf)->tail)+1;           \\\n                                                                   \\\n    (void)memcpy(&nBytesInStep, nBytesPtr, sizeof(int32_T));       \\\n    nBytesInStep += (2*sizeof(int32_T));                           \\\n    assert(nBytesInStep > 0);                                      \\\n    (circBuf)->tail += (nBytesInStep);                             \\\n    nBytesPassedEnd = (int)((circBuf)->tail - (end));              \\\n    if (nBytesPassedEnd >= 0) {                                    \\\n        (circBuf)->tail = (circBuf)->buf + nBytesPassedEnd;        \\\n    }                                                              \\\n} /* end MOVE_TAIL_ONESTEP */\n\n\n/*\n * Macro =======================================================================\n * Copy data into the circular buffer.\n */\n#define CIRCBUF_COPY_DATA(bufMem, data)                         \\\n{                                                               \\\n    (void)memcpy((bufMem).section1, (data), (bufMem).nBytes1);  \\\n    if ((bufMem).section2 != NULL) {                            \\\n        char *tmp = ((char *)(data)) + (bufMem).nBytes1;        \\\n        (void)memcpy((bufMem).section2, tmp, (bufMem).nBytes2); \\\n    }                                                           \\\n} /* end CIRCBUF_COPY_DATA */\n\n\n/* Function ====================================================================\n * Assign sections in the circular buffer for the requested number of bytes\n * (i.e., fill in the bufMem struct).  If there is no room in the circular\n * buffer return an overflow error.\n *\n * NOTE: Do not move the CircularBuffers head forward in this function!  \n *       Only move the tmpHead forward.  The actual head is not advanced\n *       until the entire time point is successfully copied into the buffer.\n *\n *       This function modifies tmpHead to point at the next available \n *       location.\n *\n *       It is possible for tmpHead to equal the tail upon entry to this\n *       function.  This does not necessarily mean that the buffer is\n *       empty (unwrapped).  It could also mean that the buffer is exactly\n *       full (this is considered as wrapped).\n */\n#ifndef EXTMODE_DISABLESIGNALMONITORING\nPRIVATE boolean_T UploadBufAssignMem(\n    CircularBuf  *circBuf,\n    int_T        nBytesToAdd,\n    char         **tmpHead,   /* in-out */\n    BufMem       *bufMem)     /* out */\n{\n    int_T       nBytesLeft;\n    boolean_T   overFlow  = false;\n    char        *end      = circBuf->buf + circBuf->bufSize; /* 1 passed end */\n\n    if ((*tmpHead > circBuf->tail) || circBuf->empty) {\n        /* buffer not wrapped */\n        nBytesLeft = (int_T)((end - *tmpHead) + (circBuf->tail - circBuf->buf));\n\n        if (nBytesLeft < nBytesToAdd) {\n            overFlow = true;\n            goto EXIT_POINT;\n        }\n\n        if ((*tmpHead + nBytesToAdd) < end) {\n            /* still not wrapped */\n            bufMem->nBytes1  = nBytesToAdd;\n            bufMem->section1 = *tmpHead;\n\n            bufMem->nBytes2  = 0;\n            bufMem->section2 = NULL;\n\n            *tmpHead += nBytesToAdd;\n        } else {\n            /* now we're wrapped */\n            bufMem->nBytes1  = (int_T)(end - *tmpHead);\n            bufMem->section1 = *tmpHead;\n\n            bufMem->nBytes2  = nBytesToAdd - bufMem->nBytes1;\n            bufMem->section2 = (bufMem->nBytes2 > 0) ? circBuf->buf : NULL;\n\n            *tmpHead = circBuf->buf + bufMem->nBytes2;\n        }  \n    } else {\n        /* wrapped */\n        nBytesLeft = (int_T)(circBuf->tail - *tmpHead);\n        if (nBytesLeft < nBytesToAdd) {\n            overFlow = true;\n            goto EXIT_POINT;\n        }\n\n        bufMem->nBytes1  = nBytesToAdd;\n        bufMem->section1 = *tmpHead;\n\n        bufMem->nBytes2  = 0;\n        bufMem->section2 = NULL;\n\n        *tmpHead += nBytesToAdd;\n    }\n    \nEXIT_POINT:\n    return(overFlow);\n} /* end UploadBufAssignMem */\n#endif /* ifndef EXTMODE_DISABLESIGNALMONITORING */\n\n/* Function ====================================================================\n * Check the trigger signals for crossings.  Return true if a trigger event is\n * encountered.  It is assumed that the trigger signals are real_T.\n */\n#ifndef EXTMODE_DISABLESIGNALMONITORING\nPRIVATE boolean_T UploadCheckTriggerSignals(int32_T upInfoIdx)\n{\n    int          i;\n    BdUploadInfo *uploadInfo      = &uploadInfoArray[upInfoIdx];\n    TriggerInfo  *trigInfo        = &uploadInfo->trigInfo;\n    real_T       *oldTrigSigVals  = trigInfo->oldTrigSigVals;\n    real_T       *oldSigPtr       = oldTrigSigVals;\n       \n    for (i=0; i<trigInfo->trigSignals.nSections; i++) {\n        UploadSection *section = &trigInfo->trigSignals.sections[i];\n        int_T         nEls     = section->nBytes / sizeof(real_T);\n\n        /*\n         * If we have a previous signal value to check, then see if we had\n         * a crossing.\n         */\n        if (trigInfo->haveOldTrigSigVal) {\n            int_T   j;\n            real_T  level   = trigInfo->level;\n            real_T  *rStart = (real_T *)section->start; /* guaranteed by host */\n            \n            for (j=0; j<nEls; j++) {\n                if (trigInfo->lookForRising && \n                    (((rStart[j] >= level) && (oldSigPtr[j] <  level)) ||\n                     ((rStart[j] >  level) && (oldSigPtr[j] == level)))) {\n                    return(true);\n                }\n                if (trigInfo->lookForFalling &&\n                    (((rStart[j] < level)  && (oldSigPtr[j] >= level)) ||\n                     ((rStart[j] == level) && (oldSigPtr[j] >  level)))) {\n                    return(true);\n                }\n            }\n        }\n\n        /*\n         * Update old signal values.\n         */\n        (void)memcpy(oldSigPtr, section->start, section->nBytes);\n        oldSigPtr += nEls;\n    }\n    assert(((unsigned char *)oldTrigSigVals) + trigInfo->trigSignals.nBytes == oldSigPtr);\n    trigInfo->haveOldTrigSigVal = true;\n    return(false);\n} /* end UploadCheckTriggerSignals */\n#endif /* ifndef EXTMODE_DISABLESIGNALMONITORING */\n\n\n/* Function ====================================================================\n * If the trigger is in the TRIGGER_FIRED state or we are collecting data for\n * pre-triggering, add data, for each tid with a hit, to the upload buffers.  \n * This function is called from within the appropriate task, once per sample\n * hit.\n *\n * The format of the packet that is sent to the host is as follows:\n *\n * definitions:\n *      pktType - A qualifier indicating any special action that needs to be\n *                taken (e.g., a termination flag following the last data point,\n *                or a flag indicating that it is the first data point after\n *                a trigger event).\n *\n *      nBytes - total number of target bytes for this packet (including the\n *               nBytes field).  nBytes worth of data represents 1 full time\n *               step of the target simulation.\n *\n *      nSys - The number of systems for which this packet contains data.\n *\n *      tid - The tid with which this data is associated.\n *\n *      upInfoIdx - upInfo index\n *\n *      t - simulation time\n *\n *      sysId - The index into the BdUploadInfo.sysTables array so that we can\n *              map the target data back to the appropriate system.  This is\n *              NOT the descendant system index!\n *\n *      data - the target simulation data (in target format)\n *\n * The packet looks like:\n * [nBytes pktType nSys tid upInfoIdx t sysId [data] sysId [data]...]\n *     |                            | |         | |          |\n *     ----------------------------- ----------- ------------\n *          pkt header          sys data     sys data\n *\n * Ints are int32_T.\n */\n#ifndef EXTMODE_DISABLESIGNALMONITORING\nPUBLIC void UploadBufAddTimePoint(int_T tid, real_T taskTime,\n                                  int32_T upInfoIdx)\n{\n    int_T        preTrig;\n    int_T        overFlow;\n    TriggerInfo  *trigInfo;\n    CircularBuf  *circBuf;\n    BdUploadInfo *uploadInfo = &uploadInfoArray[upInfoIdx];\n\n    overFlow   = false;\n    trigInfo   = &uploadInfo->trigInfo;\n    circBuf    = &uploadInfo->circBufs[tid];\n    \n    /*\n     * Check for transitions from the TRIGGER_ARMED state to either the\n     * TRIGGER_FIRED_STATE or the TRIGGER_DELAYED state.  We only do this\n     * if it is a sample hit for the trigger signal.  Note that this\n     * is the only place in the whole world that the trigger state can\n     * move from TRIGGER_ARMED_STATE to TRIGGER_DELAYED or TRIGGER_FIRED.\n     */\n    if (trigInfo->state == TRIGGER_ARMED) {\n        if (trigInfo->trigSignals.nSections == 0) {\n            /* short-circuit for manual trigger */\n            trigInfo->state = TRIGGER_FIRED;\n        } else\n            if ((tid == trigInfo->tid) &&\n                (UploadCheckTriggerSignals(upInfoIdx))) {\n                /* trig signal crossing */\n                if (trigInfo->delay == 0) {\n                    trigInfo->state = TRIGGER_FIRED;\n                    /* 0 unless pre-trig */\n                    trigInfo->count = trigInfo->preTrig.count;\n                } else {\n                    trigInfo->state = TRIGGER_DELAYED;\n                    assert(trigInfo->count == 0);\n                    \n                    /* We will be skipping this step, so the delay count is 1. */\n                    trigInfo->count = 1;\n                }\n            }\n    }\n    \n    preTrig = (trigInfo->state == TRIGGER_ARMED) &&\n        (trigInfo->preTrig.duration > 0);\n    \n    /*\n     * Handle adding data to the collection buffers - if needed.\n     */\n    if (((trigInfo->state == TRIGGER_FIRED) || preTrig) &&\n        /* bufSize == 0 means no signals in this tid */\n        circBuf->bufSize != 0) {\n        \n        int32_T     i;\n        BufMem      bufMem;\n        BufMem      pktStart;\n        int_T       size;\n        char_T *tmpHead    = circBuf->head;\n        const int_T PKT_TYPE_IDX = 0;\n        const int_T NBYTES_IDX   = 1;\n        const int_T NSYS_IDX     = 2;\n        const int_T TID_IDX      = 3;\n        const int_T UPINFO_IDX   = 4;\n\n        int32_T intHdr[5] = {0, 0, 0, 0, 0};\n        intHdr[UPINFO_IDX] = upInfoIdx;\n        \n        if (preTrig && (trigInfo->preTrig.count==trigInfo->preTrig.duration)) {\n            /* Advance the tail (we don't need the oldest point anymore). */\n            char *end = circBuf->buf + circBuf->bufSize;\n            MOVE_TAIL_ONESTEP(circBuf, end);\n            trigInfo->preTrig.count--;\n        }\n        \n        /*\n         * Save some space for the 5 integer values that make up the packet\n         * header: [pktType nBytes nSys tid upInfoIdx].\n         * The values are filled in later.\n         */\n        size = 5*sizeof(int32_T);\n        overFlow = UploadBufAssignMem(circBuf, size, &tmpHead, &pktStart);\n        if (overFlow) goto EXIT_POINT;\n\n        /*\n         * We do not want to include the packet type and number of bytes\n         * in the size calculation.  Size should represent the payload of\n         * this packet.  The packet type and number of bytes represent the\n         * packet header and are not included in the payload size.\n         */\n        size -= 2*sizeof(int32_T);\n        intHdr[NBYTES_IDX] += size;\n        \n        /* time */\n        overFlow =\n            UploadBufAssignMem(circBuf, sizeof(real_T), &tmpHead, &bufMem);\n        if (overFlow) goto EXIT_POINT;\n        intHdr[NBYTES_IDX] += sizeof(real_T);\n        \n        CIRCBUF_COPY_DATA(bufMem, &taskTime);\n\n        /*\n         * Check each system for an UploadMap. \n         */\n        for (i=0; i<uploadInfo->nSys; i++) {\n            const SysUploadTable *sysTable =\n                (const SysUploadTable *)&uploadInfo->sysTables[i];\n            \n            if ( (*sysTable->enableState != SUBSYS_RAN_BC_DISABLE) && \n                 (*sysTable->enableState != SUBSYS_RAN_BC_ENABLE_TO_DISABLE) ) {\n                UploadMap *map = sysTable->uploadMap[tid];\n\n                if (map != NULL) {\n                    int_T section;\n                    intHdr[NSYS_IDX]++;\n                    \n                    /* Add system index */\n                    size = sizeof(int32_T);\n                    overFlow =\n                        UploadBufAssignMem(circBuf, size, &tmpHead, &bufMem);\n                    if (overFlow) goto EXIT_POINT;\n                    intHdr[NBYTES_IDX] += size;\n                    \n                    CIRCBUF_COPY_DATA(bufMem, &i);\n                    \n                    /* Add data values */\n                    for (section=0; section<map->nSections; section++) {\n                        UploadSection *sect = &map->sections[section];\n                        \n#ifdef MW_DYNAMIC_STRING_SUPPORT\n                        if (sect->isString) {\n                            /* String data is [nBytes \"abc...\\0\"] */\n                            const void* strPtr = *(void**)sect->start;\n                            /* Add number of bytes of the string, including null-terminator */\n                            int32_T strNBytes = suStrlen(strPtr) + 1;\n                            char *tmpStr;\n                            \n                            overFlow = UploadBufAssignMem(circBuf, size, &tmpHead, &bufMem);\n                            if (overFlow) goto EXIT_POINT;\n                            intHdr[NBYTES_IDX] += size;\n                            CIRCBUF_COPY_DATA(bufMem, &strNBytes);\n\n                            /* Add character bytes */\n                            overFlow = UploadBufAssignMem(circBuf, strNBytes, &tmpHead, &bufMem);\n                            if (overFlow) goto EXIT_POINT;\n                            intHdr[NBYTES_IDX] += strNBytes;\n                            \n                            tmpStr = suToCStr(strPtr);\n                            CIRCBUF_COPY_DATA(bufMem, tmpStr);\n                            free(tmpStr);\n                        } else\n#endif\n                        \n                        {\n                            /* Regular cases */\n                            overFlow = UploadBufAssignMem(\n                                circBuf, sect->nBytes, &tmpHead, &bufMem);\n                            if (overFlow) goto EXIT_POINT;\n                            intHdr[NBYTES_IDX] += sect->nBytes;\n                            \n                            CIRCBUF_COPY_DATA(bufMem, sect->start);\n                        }\n                    }\n                }\n            }\n        }\n\n        /* If no systems were active then, do nothing. */\n        if (intHdr[NSYS_IDX] == 0) goto EXIT_POINT;\n        \n        /*\n         * Go back and finish the header: [nBytes pktType nSys tid]\n         */\n        \n        /* ...pktType */\n        intHdr[PKT_TYPE_IDX] = EXT_UPLOAD_LOGGING_DATA;\n\n        /* ...tid */\n        intHdr[TID_IDX] = tid;\n        CIRCBUF_COPY_DATA(pktStart, intHdr);\n\n        /*\n         * Time point successfully added to queue.\n         */\n        circBuf->head  = tmpHead;\n        circBuf->empty = false;\n        \n        if (preTrig) {\n            trigInfo->preTrig.count++;\n        }\n    }\n\nEXIT_POINT:\n    if (!preTrig) {\n        if (overFlow) {\n            trigInfo->overFlow = true;\n            trigInfo->state    = TRIGGER_TERMINATING;\n        }\n#ifdef VXWORKS\n        else if (trigInfo->state == TRIGGER_FIRED) {\n            /* allow upload server to run - if data needs to be uploaded */\n            semGive(uploadSem);\n        }\n#endif\n    } \n} /* end UploadBufAddTimePoint */\n\n\n/* Function ====================================================================\n * Called at the base rate, controls the state of data logging including:\n *   - monitoring the trigger signal for a trigger event\n *   - managing transition of most trigger states\n *      o a separate function (UploadCheckEndTrigger manages the duration\n *        count and the transition from fired to terminating at the end\n *        of the data collection event).\n *\n * NOTE:\n *  o This function should be called after mdlOutputs for the base rate\n */\nPUBLIC void UploadCheckTrigger(int32_T upInfoIdx, int_T numSampTimes)\n{\n    BdUploadInfo *uploadInfo = &uploadInfoArray[upInfoIdx];\n    TriggerInfo  *trigInfo   = &uploadInfo->trigInfo;\n\n    if (trigInfo->state == TRIGGER_UNARMED) return;\n\n    if (trigInfo->state == TRIGGER_HOLDING_OFF) {\n        if (trigInfo->count++ == trigInfo->holdOff) {\n            UploadArmTrigger(upInfoIdx, numSampTimes);\n        } else {\n            return;\n        }\n    }\n\n    /*\n     * Transitions from the TRIGGER_ARMED_STATE to the TRIGGER_DELAYED\n     * state or to the TRIGGER_FIRED_STATE are checked for and realized\n     * within the task (tid) associated with the trigger signal.\n     * See UploadBufAddTimePoint().\n     */ \n    \n    /*\n     * Look for transitions from the TRIGGER_DELAYED state.  The TRIGGER_FIRED\n     * state always follows the TRIGGER_DELAYED state.\n     *\n     * NOTE: the trigInfo count field is first used to count the trigger delay\n     *       and then used to count the trigger duration\n     */\n    if (trigInfo->state == TRIGGER_DELAYED) {\n        if (trigInfo->count++ >= trigInfo->delay) {\n            trigInfo->count = trigInfo->preTrig.count; /* 0 unless pre-trig */\n            trigInfo->state = TRIGGER_FIRED;\n            if (trigInfo->preTrig.duration > 0) {\n                trigInfo->preTrig.checkUnderFlow = true;\n            }\n#ifdef VERBOSE\n            printf(\"\\nTrigger fired!\\n\");\n#endif\n        }\n    }\n} /* end UploadCheckTrigger */\n\n\n/* Function ====================================================================\n * Called at the base rate, controls the state of data logging wrt\n *  o incrementing the duration count\n *  o managing the transition to the trigger terminating state\n *\n * NOTES:\n *  o Call this function at the very end of a step.\n *  o Also see UploadCheckTrigger()\n */\nPUBLIC void UploadCheckEndTrigger(int32_T upInfoIdx)\n{\n    BdUploadInfo *uploadInfo = &uploadInfoArray[upInfoIdx];\n    TriggerInfo *trigInfo    = &uploadInfo->trigInfo;\n\n    if (trigInfo->state == TRIGGER_UNARMED) return;\n\n    /*\n     * Increment duration count and terminate the data logging event if\n     * the duration has been met.\n     */\n    if (trigInfo->state == TRIGGER_FIRED) {\n        trigInfo->count++;\n        if (trigInfo->count == trigInfo->duration) {\n            trigInfo->state = TRIGGER_TERMINATING;\n        }\n    }\n\n#ifdef VXWORKS\n    if (trigInfo->state == TRIGGER_TERMINATING) {\n        /* Let upload server run to ensure that term pkt is sent to host. */\n        semGive(uploadSem);\n    }\n#endif\n} /* end UploadCheckEndTrigger */\n\n\n/* Function ===================================================================\n * Search through the upload buffers and fill out the internal copy of the\n * buffer list.  It contains a list of all buffer memory (1 entry per non-empty\n * tid buffer) that needs to be sent to the host.  Fill out the fields of the\n * specified ExtBufMemList (passed in by ext_svr) to provide public, read-only\n * access.\n */\nPRIVATE void SetExtBufListFields(ExtBufMemList *extBufList,\n                                 int32_T       upInfoIdx,\n                                 int_T         numSampTimes)\n{\n    int_T       tid;\n    BdUploadInfo *uploadInfo = &uploadInfoArray[upInfoIdx];\n    BufMemList   *bufList    = &uploadInfo->bufMemList;\n\n    bufList->nActiveBufs = 0;\n\n    for (tid=0; tid<numSampTimes; tid++) {\n        CircularBuf *circBuf = &uploadInfo->circBufs[tid];\n\n        if (!circBuf->empty) {\n            BufMem  *bufMem;\n            char_T  *head;\n            char_T  *tail   = circBuf->tail;\n            int_T   size    = circBuf->bufSize;\n\n            \n#ifdef EXTMODE_PROTECT_CRITICAL_REGIONS\n            /* \n             * disable interrupts around this critical region. We need to \n             * guarantee that reading the head pointer is an atomic \n             * operation.\n             */\n            EXTMODE_DISABLE_INTERRUPTS;\n#endif\n\n            head = circBuf->head;\n\n            \n#ifdef EXTMODE_PROTECT_CRITICAL_REGIONS\n            /* re-enable interrupts */\n            EXTMODE_ENABLE_INTERRUPTS;\n#endif\n\n            /* Validate that head/tail ptrs are within allocated range. */\n            assert((head >= circBuf->buf) && (tail >= circBuf->buf));\n            assert((head < circBuf->buf + circBuf->bufSize) &&\n                   (tail < circBuf->buf + circBuf->bufSize));\n\n            bufMem = &bufList->bufs[bufList->nActiveBufs];\n            bufList->tids[bufList->nActiveBufs] = tid;\n            assert(bufList->nActiveBufs < bufList->maxBufs);\n            bufList->nActiveBufs++;\n\n            bufMem->section1 = tail;\n            circBuf->newTail = head;\n\n            if (head > tail) {\n                /* not wrapped - only one section required */\n                bufMem->nBytes1  = (int_T)(head - tail);\n\n                bufMem->nBytes2  = 0;\n                bufMem->section2 = NULL;\n            } else {\n                /* wrapped - 2 sections required */\n                bufMem->nBytes1 = (int_T)(circBuf->buf + size - tail);\n\n                bufMem->nBytes2  = (int_T)(head - circBuf->buf);\n                bufMem->section2 = circBuf->buf;\n            }\n        }\n    }\n\n    /*\n     * Provide ext_svr with readonly access to the bufMemList.\n     */\n    extBufList->nActiveBufs = bufList->nActiveBufs;\n    extBufList->bufs        = (const BufMem *)bufList->bufs;\n    extBufList->tids        = (const int_T *)bufList->tids;\n} /* end SetExtBufListFields */\n\n\n/* Function ===================================================================\n * Set the internal copy of the buffer list to \"empty\" & fill out the fields\n * of the specified ExtBufMemList (passed in by ext_svr) to provide public,\n * read only access.\n */\nPRIVATE void SetExtBufListFieldsForEmptyList(ExtBufMemList *extBufList,\n                                             int32_T       upInfoIdx)\n{\n    BdUploadInfo *uploadInfo = &uploadInfoArray[upInfoIdx];\n    BufMemList   *bufList    = &uploadInfo->bufMemList;\n\n    bufList->nActiveBufs = 0;\n\n    extBufList->nActiveBufs = bufList->nActiveBufs;\n    extBufList->bufs        = (const BufMem *)NULL;\n} /* end SetExtBufListFieldsForEmptyList */\n\n\n/* Function ====================================================================\n * Called by ext_svr (background task), this function checks all buffers for\n * data and returns a list of buffer memory to be sent to the host.\n */\nPUBLIC void UploadBufGetData(ExtBufMemList *extBufList,\n                             int32_T       upInfoIdx,\n                             int_T         numSampTimes)\n{\n    BdUploadInfo *uploadInfo = &uploadInfoArray[upInfoIdx];\n    TriggerInfo  *trigInfo   = &uploadInfo->trigInfo;\n    TriggerState trigState = trigInfo->state;\n \n    if ((trigState == TRIGGER_FIRED) ||\n        (trigState == TRIGGER_TERMINATING)) {\n\n        /* Make sure we start with an empty list */\n        SetExtBufListFieldsForEmptyList(extBufList, upInfoIdx);\n        SetExtBufListFields(extBufList, upInfoIdx, numSampTimes);\n\n        /*\n         * If all bufs are empty and we are terminating then we're now done!\n         */\n        if ((extBufList->nActiveBufs == 0) &&\n            (trigState == TRIGGER_TERMINATING)) {\n\n            host_upstatus_is_uploading = false;\n\n            if (trigInfo->holdOff == TRIGMODE_ONESHOT) {\n                SendPktToHost(EXT_TERMINATE_LOG_SESSION, sizeof(int32_T),\n                              (char *)&upInfoIdx);\n                UploadEndLoggingSession(upInfoIdx, numSampTimes);\n            } else {\n                SendPktToHost(EXT_TERMINATE_LOG_EVENT, sizeof(int32_T),\n                              (char *)&upInfoIdx);\n                trigInfo->count = 0;\n                trigInfo->state = TRIGGER_HOLDING_OFF;\n            }\n        }\n    } else {\n        SetExtBufListFieldsForEmptyList(extBufList, upInfoIdx);\n    }\n} /* end UploadBufGetData */\n#endif /* ifndef EXTMODE_DISABLESIGNALMONITORING */\n\n\n/* [EOF] updown.c */\n\n/* LocalWords:  DType pbuf NPARAMS dtype tran Els EXTMODE HDR abc\n * LocalWords:  DISABLEPARAMETERTUNING bufs buf blockio tids sys's nbuf sigs\n * LocalWords:  tid's DISABLESIGNALMONITORING uploadinfo NULL'ed vals oneshot\n * LocalWords:  sem svr TRIGMODE ONESTEP CIRCBUF tmp\n */\n"}],"coverage":[{"id":"SimulinkCoverage","name":"Simulink Coverage","files":[]},{"id":"Bullseye","name":"Bullseye Coverage","files":[]},{"id":"LDRA","name":"LDRA Testbed","files":[]}],"features":{"annotation":false,"coverage":true,"profiling":true,"tooltip":true,"coverageTooltip":true,"showJustificationLinks":true,"useMWTable":false,"showProfilingInfo":true,"showTaskSummary":true}};